{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/img/logo.png","path":"img/logo.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1681376305352},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"0f374904caef5c05adf4a471254fdaa4d6c9b995","modified":1681376638396},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":499162500000},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":499162500000},{"_id":"public/2023/04/13/hello-world/index.html","hash":"a98b74b6c52d31464c571a594ac6ea7c2f561749","modified":1681376708364},{"_id":"public/index.html","hash":"07d51138a0bcb025788a1c89a82155f681147153","modified":1681458081946},{"_id":"public/archives/index.html","hash":"12cb8e9baf330337c4dc743aa138fc6ab1a3b057","modified":1681458081946},{"_id":"public/archives/2023/index.html","hash":"51c44b5f323a1ba241e8c4de4cb3a5ac4d7dc7a1","modified":1681458081946},{"_id":"public/archives/2023/04/index.html","hash":"b44bf5d2de7c19018e3871fb89b4a4791823da71","modified":1681458081946},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1681458081946},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1681458081946},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1681458081946},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1681458081946},{"_id":"public/css/style.css","hash":"d17600a160c9934645627776282f9317546a3436","modified":1681458081946},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1681458081946},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1681458081946},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1681458081946},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1681458081946},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1681458081946},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1681458081946},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1681458081946},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"426d281f1ea780e8c9e9212cacf47554475aac81","modified":1681382897203},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"088788e149051fc0a3c6096ba95e35a8344de04b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":499162500000},{"_id":"source/img/logo.png","hash":"d4e1305e54ff0561aa5968458914f1102d703435","modified":1681377128807},{"_id":"source/_posts/ES6-新特性.md","hash":"74cbc493ec7d06c9a250bd7febb26a40c24fad94","modified":1681377687872},{"_id":"source/_posts/原型与原型链.md","hash":"b530d1a2532c68f1a9f6ab0c50ac801ba21ab0d6","modified":1681378813698},{"_id":"source/_posts/原型与原型链/img.png","hash":"00dec386ef4984435c663709db77cbc8632128e7","modified":1681378477469},{"_id":"source/_posts/原型与原型链/img_1.png","hash":"5ef5695c7f7305144fd51793e4c9ace06ac8da04","modified":1681378703447},{"_id":"source/_posts/原型与原型链/img_2.png","hash":"5ef5695c7f7305144fd51793e4c9ace06ac8da04","modified":1681378745430},{"_id":"source/_posts/原型与原型链/img_3.png","hash":"5ef5695c7f7305144fd51793e4c9ace06ac8da04","modified":1681378788902},{"_id":"source/_posts/CSS-overflow-anchor属性的一些坑.md","hash":"3c318e6c6b215eaad14794059862d8e563f04f6d","modified":1681379171440},{"_id":"source/_posts/前端对接GPT实现打字机效果.md","hash":"31421a5d468830c842619a947db9269e6f46d80d","modified":1681379272440},{"_id":"source/_posts/前端日志上报的实现.md","hash":"63653aae9003f14ddd23ebc460632129968ae90d","modified":1681379325603},{"_id":"source/_posts/Javascript/原型与原型链/img_3.png","hash":"5ef5695c7f7305144fd51793e4c9ace06ac8da04","modified":1681378788902},{"_id":"source/_posts/Javascript/原型与原型链/img_1.png","hash":"5ef5695c7f7305144fd51793e4c9ace06ac8da04","modified":1681378703447},{"_id":"source/_posts/Javascript/原型与原型链/img_2.png","hash":"5ef5695c7f7305144fd51793e4c9ace06ac8da04","modified":1681378745430},{"_id":"source/_posts/Javascript/原型与原型链/img.png","hash":"00dec386ef4984435c663709db77cbc8632128e7","modified":1681378477469},{"_id":"source/_posts/杂谈/前端日志上报的实现.md","hash":"deeedce4c6d2d6aabbf8bcc377bac05a47dbb5ca","modified":1681379684498},{"_id":"source/_posts/Javascript/ES6-新特性.md","hash":"402fa2938f39c46b83fa11414c55166e2566fb70","modified":1681379684498},{"_id":"source/_posts/Css/CSS-overflow-anchor属性的一些坑.md","hash":"9b49f780a364193172b4eaf471dce83a7a4a3aa1","modified":1681379684498},{"_id":"source/_posts/杂谈/前端对接GPT实现打字机效果.md","hash":"1cab6351d9d3b44d51e01de249ee7cba959ec0bb","modified":1681379684498},{"_id":"source/_posts/Javascript/原型与原型链.md","hash":"4e61446ecbe55f3f0547d94033c438b6e0f972e7","modified":1681379684498},{"_id":"source/about/index.md","hash":"5c40b76a26bbf6e6077679de143c73d8e4cd2587","modified":1681379728547},{"_id":"source/_posts/npm/使用patch-package修改第三方模块.md","hash":"e365d2b8eb377da9bb58b15b552091894ee6b43a","modified":1681457984683},{"_id":"public/local-search.xml","hash":"2f71d6f8d750b35565fa391c4c7eab612cff5145","modified":1681458081946},{"_id":"public/about/index.html","hash":"1edd538eafe241858f3ccbc52c46cd0b92e0034e","modified":1681458081946},{"_id":"public/categories/Javascript/index.html","hash":"97f00b74127d84ed0021744d5322dc83d010a32a","modified":1681458081946},{"_id":"public/categories/Css/index.html","hash":"e4bec22f3541ceaf50d18c92b128df5f4dfce045","modified":1681458081946},{"_id":"public/categories/杂谈/index.html","hash":"a9cdf550f1aced17993a8c2a56d95ab8008f562c","modified":1681458081946},{"_id":"public/tags/es6/index.html","hash":"e803de886dbeb6416ceaa27ea8d1b0b581659b2b","modified":1681458081946},{"_id":"public/tags/javascript/index.html","hash":"bc16c3ce1b81f178fdbc0e473a22eacb30a57d38","modified":1681458081946},{"_id":"public/tags/css/index.html","hash":"ed57e07cdd0fb46431e979f413976cab22365995","modified":1681458081946},{"_id":"public/tags/nodejs/index.html","hash":"60952e81cd8b0965843f9f82983b69cb86b59319","modified":1681458081946},{"_id":"public/tags/SSE/index.html","hash":"a2cea90b5a80b582e32ed76f70af464db8a03e64","modified":1681458081946},{"_id":"public/tags/npm/index.html","hash":"0910dd159a58f9f3592f9f80d5b7997f03d4dd99","modified":1681458081946},{"_id":"public/tags/日志/index.html","hash":"35934193b30767258980e2c58477d718b0dcd277","modified":1681458081946},{"_id":"public/404.html","hash":"412be2f5cd6817f940973fb3f061c169facf14a2","modified":1681458081946},{"_id":"public/tags/patch-package/index.html","hash":"09f745f2fe1154eb4326a3e8896d3d88b27c9616","modified":1681458081946},{"_id":"public/tags/ChatGPT/index.html","hash":"633d960f495ab0c0be978e8a46c5df253d4dec27","modified":1681458081946},{"_id":"public/tags/index.html","hash":"81d0e21b2eb4236be5456127df8027cde4b8e706","modified":1681458081946},{"_id":"public/categories/index.html","hash":"67c376758a69c7918c4f90c0dcfadfc0135b9d1b","modified":1681458081946},{"_id":"public/links/index.html","hash":"f5ea7e0639e80f570e21159254f8a3e1a14d367a","modified":1681458081946},{"_id":"public/2023/04/13/杂谈/前端日志上报的实现/index.html","hash":"4d6a1637020cab10efef8a0342892fca73e78274","modified":1681458081946},{"_id":"public/2023/04/13/杂谈/前端对接GPT实现打字机效果/index.html","hash":"b07413fa338ac5121748ab1bb005e187b9f17dcd","modified":1681458081946},{"_id":"public/2023/04/13/Css/CSS-overflow-anchor属性的一些坑/index.html","hash":"322f059470ff9d149a7341354f3c5693f56f2667","modified":1681458081946},{"_id":"public/2023/04/14/npm/使用patch-package修改第三方模块/index.html","hash":"b76b9c5b896c9df04f74cfc15c59844caa19730f","modified":1681458081946},{"_id":"public/2023/04/13/Javascript/原型与原型链/index.html","hash":"7fdc9ab007c3bdce1dabeec782cbb6e20c9b5f6a","modified":1681458081946},{"_id":"public/2023/04/13/Javascript/ES6-新特性/index.html","hash":"61903cd1ed4f46ef924e544a9bbb84ffa6161493","modified":1681458081946}],"Category":[{"name":"npm","_id":"clgexw4xu0000fpc3eqj2amry"},{"name":"Javascript","_id":"clgey1vwu000nfpc38ut1hzjk"},{"name":"Css","_id":"clgey1vwy000pfpc32dlsevur"},{"name":"杂谈","_id":"clgey1vx0000rfpc38fes53mu"}],"Data":[],"Page":[{"title":"about","date":"2023-04-13T09:55:28.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-04-13 17:55:28\n---\n","updated":"2023-04-13T09:55:28.547Z","path":"about/index.html","_id":"clgey2ts80000p1c3ca8w6o45","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"ES6 新特性","date":"2023-04-13T09:19:44.000Z","_content":"\n# ES6 新特性\n\n本文只是简单概括ES6的一些新特性，想要详细了解，可以参阅[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla) [ES6入门](https://es6.ruanyifeng.com/)\n\nECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n## let 与 const\n\n`ES2015(ES6)`新增加了两个重要的`JavaScript`关键字: `let`和`const`。 `ES6`明确规定，代码块内如果存在`let`或者`const`，代码块会对这些命令声明的变量从块的开始就形成一个**封闭作用域**。代码块内，在**声明变量之前**使用它会**报错**，称为**暂时性死区**。 `ES6`的块级作用域必须有大括号，如果没有大括号，`JavaScript`引擎就认为不存在块级作用域。\n\n+ `let`和`const`只能声明一次，`var`可以声明多次。\n+ `var`会变量提升，`let`与`const`也存在变量提升但有所不同。\n+ `const`声明一个只读的常量，一旦声明，常量的值就不能改变。\n+ `const`和`let`在全局作用域中声明的变量不会挂载到`window`上。\n+ `let`和`const`声明的变量只在其声明所在的代码块内有效，形成块级作用域。\n+ `const`其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。对于基本数据类型`number、string 、boolean`等，值就保存在变量指向的那个内存地址，因此`const` 声明的简单类型变量等同于常量。而引用类型`object，array，function`等，变量指向的内存地址其实是保存了一个指向实际数据的指针，所以`const`只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了。\n\n## 解构赋值\n\n`ES6`允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。\n\n```\nlet [a, b, c] = [1, 2, 3]; // 基本\nlet [a, [[b], c]] = [1, [[2], 3]]; //嵌套\nlet [a, , b] = [1, 2, 3]; // 可忽略\nlet [a = 1, b] = []; // a = 1, b = undefined // 不完全解构\nlet [a, ...b] = [1, 2, 3]; // 剩余运算符\nlet [a, b, c, d, e] = 'hello'; // 字符串等\nlet { a, b } = { a: 'aaa', b: 'bbb' }; // 对象模型的解构 前后两个kay需对应\n```\n\n## Symbol\n\n`ES6`引入了一种新的原始数据类型`Symbol`，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 `ES6`数据类型除了`Number`、`String`、`Boolean`、 `Object`、`null`和`undefined`，还新增了 `Symbol`。\n\n```\nlet s1 = Symbol(\"s\");\nlet s2 = Symbol(\"s\");\nconsole.log(s1 === s2); //false\n```\n\n## Spread / Rest 操作符\n\n`Spread` 用于将数组作为参数直接传入函数。\n\n```\nvar s = ['1', '2', '3'];\nfunction f(s1,s2,s3){\n    console.log(`Hello ${s1},${s2},${s3}`); //ES6新增字符串中加入变量和表达式\n}\nf(...s); //Hello 1,2,3\n```\n\n`Rest` 用于函数传参传递数组。\n\n```\nfunction f(...args){\n    console.log(args);\n}\nf(1,2,3,4,5); //[1, 2, 3, 4, 5]\n```\n\n## 箭头函数\n\n`ES6`中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 `=>`，紧接着是函数体，特别需要注意的是箭头函数是继承当前上下文的`this`关键字。\n\n```\nvar add = (a, b) => a + b;\nvar show = a => console.log(a);\nvar test = (a,b,c) => {console.log(a,b,c);return a+b+c;}\nadd(1,1); //2\nshow(1); //1\ntest(1,1,1); //1 1 1\n```\n\n## 参数默认值\n\n```\nfunction f(a = 1){\n    console.log(a);\n}\nf(); //1\nf(11); //11\n```\n\n## 迭代器\n\n+ `Symbol.iterator` 一个统一的接口，它的作用是使各种数据结构可被便捷的访问。\n+ for of 是 ES6 新引入的循环，用于替代 `for..in` 和 `forEach()`。\n\n\n## 类\n\n`ES6`提供了更接近传统语言的写法，引入了`class`这个概念，作为对象的模板。通过`class`关键字，可以定义类，与多数传统语言类似。不过，`ES6`的`class`不是新的对象继承模型，它只是原型链的语法糖表现形式。\n\n```\nclass Me {\n  constructor() {\n    console.log(\"constructor\");\n  }\n  study() {\n    console.log('study');\n  }\n}\n\nconsole.log(typeof Me); //function\nlet me = new Me(); //constructor\nme.study(); //study\n```\n\n## Promise 对象\n\n`Promise`是异步编程的一种解决方案。\n\n从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。\nPromise异步操作有三种状态：`pending`、`fulfilled`和`rejected`。除了异步操作的结果，任何其他操作都无法改变这个状态。\n`then`方法接收两个函数作为参数，第一个参数是`Promise`执行成功时的回调，第二个参数是 `Promise`执行失败时的回调，两个函数只会有一个被调用。\n\n```\nconst p1 = new Promise(function(resolve,reject){\n    resolve('resolve');\n}); \nconst p2 = new Promise(function(resolve,reject){\n    reject('reject');\n});\np1.then(function(v){  \n    console.log(v); //resolve\n});\np2.then(function(v){ \n    console.log(v);\n},\nfunction(v){\n    console.log(v); //reject\n});\n\n```","source":"_posts/Javascript/ES6-新特性.md","raw":"---\ntitle: ES6 新特性\ntags:\n  - javascript\n  - es6\ncategories:\n  - Javascript\ndate: 2023-04-13 17:19:44\n---\n\n# ES6 新特性\n\n本文只是简单概括ES6的一些新特性，想要详细了解，可以参阅[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla) [ES6入门](https://es6.ruanyifeng.com/)\n\nECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n## let 与 const\n\n`ES2015(ES6)`新增加了两个重要的`JavaScript`关键字: `let`和`const`。 `ES6`明确规定，代码块内如果存在`let`或者`const`，代码块会对这些命令声明的变量从块的开始就形成一个**封闭作用域**。代码块内，在**声明变量之前**使用它会**报错**，称为**暂时性死区**。 `ES6`的块级作用域必须有大括号，如果没有大括号，`JavaScript`引擎就认为不存在块级作用域。\n\n+ `let`和`const`只能声明一次，`var`可以声明多次。\n+ `var`会变量提升，`let`与`const`也存在变量提升但有所不同。\n+ `const`声明一个只读的常量，一旦声明，常量的值就不能改变。\n+ `const`和`let`在全局作用域中声明的变量不会挂载到`window`上。\n+ `let`和`const`声明的变量只在其声明所在的代码块内有效，形成块级作用域。\n+ `const`其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。对于基本数据类型`number、string 、boolean`等，值就保存在变量指向的那个内存地址，因此`const` 声明的简单类型变量等同于常量。而引用类型`object，array，function`等，变量指向的内存地址其实是保存了一个指向实际数据的指针，所以`const`只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了。\n\n## 解构赋值\n\n`ES6`允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。\n\n```\nlet [a, b, c] = [1, 2, 3]; // 基本\nlet [a, [[b], c]] = [1, [[2], 3]]; //嵌套\nlet [a, , b] = [1, 2, 3]; // 可忽略\nlet [a = 1, b] = []; // a = 1, b = undefined // 不完全解构\nlet [a, ...b] = [1, 2, 3]; // 剩余运算符\nlet [a, b, c, d, e] = 'hello'; // 字符串等\nlet { a, b } = { a: 'aaa', b: 'bbb' }; // 对象模型的解构 前后两个kay需对应\n```\n\n## Symbol\n\n`ES6`引入了一种新的原始数据类型`Symbol`，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 `ES6`数据类型除了`Number`、`String`、`Boolean`、 `Object`、`null`和`undefined`，还新增了 `Symbol`。\n\n```\nlet s1 = Symbol(\"s\");\nlet s2 = Symbol(\"s\");\nconsole.log(s1 === s2); //false\n```\n\n## Spread / Rest 操作符\n\n`Spread` 用于将数组作为参数直接传入函数。\n\n```\nvar s = ['1', '2', '3'];\nfunction f(s1,s2,s3){\n    console.log(`Hello ${s1},${s2},${s3}`); //ES6新增字符串中加入变量和表达式\n}\nf(...s); //Hello 1,2,3\n```\n\n`Rest` 用于函数传参传递数组。\n\n```\nfunction f(...args){\n    console.log(args);\n}\nf(1,2,3,4,5); //[1, 2, 3, 4, 5]\n```\n\n## 箭头函数\n\n`ES6`中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 `=>`，紧接着是函数体，特别需要注意的是箭头函数是继承当前上下文的`this`关键字。\n\n```\nvar add = (a, b) => a + b;\nvar show = a => console.log(a);\nvar test = (a,b,c) => {console.log(a,b,c);return a+b+c;}\nadd(1,1); //2\nshow(1); //1\ntest(1,1,1); //1 1 1\n```\n\n## 参数默认值\n\n```\nfunction f(a = 1){\n    console.log(a);\n}\nf(); //1\nf(11); //11\n```\n\n## 迭代器\n\n+ `Symbol.iterator` 一个统一的接口，它的作用是使各种数据结构可被便捷的访问。\n+ for of 是 ES6 新引入的循环，用于替代 `for..in` 和 `forEach()`。\n\n\n## 类\n\n`ES6`提供了更接近传统语言的写法，引入了`class`这个概念，作为对象的模板。通过`class`关键字，可以定义类，与多数传统语言类似。不过，`ES6`的`class`不是新的对象继承模型，它只是原型链的语法糖表现形式。\n\n```\nclass Me {\n  constructor() {\n    console.log(\"constructor\");\n  }\n  study() {\n    console.log('study');\n  }\n}\n\nconsole.log(typeof Me); //function\nlet me = new Me(); //constructor\nme.study(); //study\n```\n\n## Promise 对象\n\n`Promise`是异步编程的一种解决方案。\n\n从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。\nPromise异步操作有三种状态：`pending`、`fulfilled`和`rejected`。除了异步操作的结果，任何其他操作都无法改变这个状态。\n`then`方法接收两个函数作为参数，第一个参数是`Promise`执行成功时的回调，第二个参数是 `Promise`执行失败时的回调，两个函数只会有一个被调用。\n\n```\nconst p1 = new Promise(function(resolve,reject){\n    resolve('resolve');\n}); \nconst p2 = new Promise(function(resolve,reject){\n    reject('reject');\n});\np1.then(function(v){  \n    console.log(v); //resolve\n});\np2.then(function(v){ \n    console.log(v);\n},\nfunction(v){\n    console.log(v); //reject\n});\n\n```","slug":"Javascript/ES6-新特性","published":1,"updated":"2023-04-13T09:54:44.498Z","_id":"clgey0sev0007fpc3ah1k8wl8","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"ES6-新特性\"><a href=\"#ES6-新特性\" class=\"headerlink\" title=\"ES6 新特性\"></a>ES6 新特性</h1><p>本文只是简单概括ES6的一些新特性，想要详细了解，可以参阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\">MDN</a> <a href=\"https://es6.ruanyifeng.com/\">ES6入门</a></p>\n<p>ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n<h2 id=\"let-与-const\"><a href=\"#let-与-const\" class=\"headerlink\" title=\"let 与 const\"></a>let 与 const</h2><p><code>ES2015(ES6)</code>新增加了两个重要的<code>JavaScript</code>关键字: <code>let</code>和<code>const</code>。 <code>ES6</code>明确规定，代码块内如果存在<code>let</code>或者<code>const</code>，代码块会对这些命令声明的变量从块的开始就形成一个<strong>封闭作用域</strong>。代码块内，在<strong>声明变量之前</strong>使用它会<strong>报错</strong>，称为<strong>暂时性死区</strong>。 <code>ES6</code>的块级作用域必须有大括号，如果没有大括号，<code>JavaScript</code>引擎就认为不存在块级作用域。</p>\n<ul>\n<li><code>let</code>和<code>const</code>只能声明一次，<code>var</code>可以声明多次。</li>\n<li><code>var</code>会变量提升，<code>let</code>与<code>const</code>也存在变量提升但有所不同。</li>\n<li><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变。</li>\n<li><code>const</code>和<code>let</code>在全局作用域中声明的变量不会挂载到<code>window</code>上。</li>\n<li><code>let</code>和<code>const</code>声明的变量只在其声明所在的代码块内有效，形成块级作用域。</li>\n<li><code>const</code>其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。对于基本数据类型<code>number、string 、boolean</code>等，值就保存在变量指向的那个内存地址，因此<code>const</code> 声明的简单类型变量等同于常量。而引用类型<code>object，array，function</code>等，变量指向的内存地址其实是保存了一个指向实际数据的指针，所以<code>const</code>只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了。</li>\n</ul>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p><code>ES6</code>允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">let [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-regexp\">//</span> 基本<br>let [a, [[b], c]] = [<span class=\"hljs-number\">1</span>, [[<span class=\"hljs-number\">2</span>], <span class=\"hljs-number\">3</span>]]; <span class=\"hljs-regexp\">//</span>嵌套<br>let [a, , b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-regexp\">//</span> 可忽略<br>let [a = <span class=\"hljs-number\">1</span>, b] = []; <span class=\"hljs-regexp\">//</span> a = <span class=\"hljs-number\">1</span>, b = undefined <span class=\"hljs-regexp\">//</span> 不完全解构<br>let [a, ...b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-regexp\">//</span> 剩余运算符<br>let [a, b, c, d, e] = <span class=\"hljs-string\">&#x27;hello&#x27;</span>; <span class=\"hljs-regexp\">//</span> 字符串等<br>let &#123; a, b &#125; = &#123; a: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, b: <span class=\"hljs-string\">&#x27;bbb&#x27;</span> &#125;; <span class=\"hljs-regexp\">//</span> 对象模型的解构 前后两个kay需对应<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p><code>ES6</code>引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 <code>ES6</code>数据类型除了<code>Number</code>、<code>String</code>、<code>Boolean</code>、 <code>Object</code>、<code>null</code>和<code>undefined</code>，还新增了 <code>Symbol</code>。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let s1 <span class=\"hljs-operator\">=</span> Symbol(<span class=\"hljs-string\">&quot;s&quot;</span>)<span class=\"hljs-comment\">;</span><br>let s2 <span class=\"hljs-operator\">=</span> Symbol(<span class=\"hljs-string\">&quot;s&quot;</span>)<span class=\"hljs-comment\">;</span><br>console.log(s1 <span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span> s2)<span class=\"hljs-comment\">; //false</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Spread-x2F-Rest-操作符\"><a href=\"#Spread-x2F-Rest-操作符\" class=\"headerlink\" title=\"Spread &#x2F; Rest 操作符\"></a>Spread &#x2F; Rest 操作符</h2><p><code>Spread</code> 用于将数组作为参数直接传入函数。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> s = [<span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-string\">&#x27;3&#x27;</span>];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">s1,s2,s3</span>)&#123;<br>    <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;s1&#125;</span>,<span class=\"hljs-subst\">$&#123;s2&#125;</span>,<span class=\"hljs-subst\">$&#123;s3&#125;</span>`</span>); <span class=\"hljs-comment\">//ES6新增字符串中加入变量和表达式</span><br>&#125;<br>f(...s); <span class=\"hljs-comment\">//Hello 1,2,3</span><br></code></pre></td></tr></table></figure>\n\n<p><code>Rest</code> 用于函数传参传递数组。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span>&#123;<br>    console.log(args);<br>&#125;<br>f(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">//[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p><code>ES6</code>中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 <code>=&gt;</code>，紧接着是函数体，特别需要注意的是箭头函数是继承当前上下文的<code>this</code>关键字。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b;<br><span class=\"hljs-keyword\">var</span> show = <span class=\"hljs-function\"><span class=\"hljs-params\">a</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(a);<br><span class=\"hljs-keyword\">var</span> test = <span class=\"hljs-function\">(<span class=\"hljs-params\">a,b,c</span>) =&gt;</span> &#123;<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(a,b,c);<span class=\"hljs-keyword\">return</span> a+b+c;&#125;<br>add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//2</span><br>show(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//1</span><br>test(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//1 1 1</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">function <span class=\"hljs-built_in\">f</span>(a = <span class=\"hljs-number\">1</span>)&#123;<br>    console<span class=\"hljs-selector-class\">.log</span>(a);<br>&#125;<br><span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">//1</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">11</span>); <span class=\"hljs-comment\">//11</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><ul>\n<li><code>Symbol.iterator</code> 一个统一的接口，它的作用是使各种数据结构可被便捷的访问。</li>\n<li>for of 是 ES6 新引入的循环，用于替代 <code>for..in</code> 和 <code>forEach()</code>。</li>\n</ul>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p><code>ES6</code>提供了更接近传统语言的写法，引入了<code>class</code>这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类，与多数传统语言类似。不过，<code>ES6</code>的<code>class</code>不是新的对象继承模型，它只是原型链的语法糖表现形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Me</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;constructor&quot;</span>);<br>  &#125;<br>  <span class=\"hljs-title function_\">study</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;study&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Me</span>); <span class=\"hljs-comment\">//function</span><br><span class=\"hljs-keyword\">let</span> me = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Me</span>(); <span class=\"hljs-comment\">//constructor</span><br>me.<span class=\"hljs-title function_\">study</span>(); <span class=\"hljs-comment\">//study</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-对象\"><a href=\"#Promise-对象\" class=\"headerlink\" title=\"Promise 对象\"></a>Promise 对象</h2><p><code>Promise</code>是异步编程的一种解决方案。</p>\n<p>从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<br>Promise异步操作有三种状态：<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>。除了异步操作的结果，任何其他操作都无法改变这个状态。<br><code>then</code>方法接收两个函数作为参数，第一个参数是<code>Promise</code>执行成功时的回调，第二个参数是 <code>Promise</code>执行失败时的回调，两个函数只会有一个被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;resolve&#x27;</span>);<br>&#125;); <br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>    <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-string\">&#x27;reject&#x27;</span>);<br>&#125;);<br>p1.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>)&#123;  <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v); <span class=\"hljs-comment\">//resolve</span><br>&#125;);<br>p2.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>)&#123; <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;,<br><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v); <span class=\"hljs-comment\">//reject</span><br>&#125;);<br><br></code></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ES6-新特性\"><a href=\"#ES6-新特性\" class=\"headerlink\" title=\"ES6 新特性\"></a>ES6 新特性</h1><p>本文只是简单概括ES6的一些新特性，想要详细了解，可以参阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla\">MDN</a> <a href=\"https://es6.ruanyifeng.com/\">ES6入门</a></p>\n<p>ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>\n<h2 id=\"let-与-const\"><a href=\"#let-与-const\" class=\"headerlink\" title=\"let 与 const\"></a>let 与 const</h2><p><code>ES2015(ES6)</code>新增加了两个重要的<code>JavaScript</code>关键字: <code>let</code>和<code>const</code>。 <code>ES6</code>明确规定，代码块内如果存在<code>let</code>或者<code>const</code>，代码块会对这些命令声明的变量从块的开始就形成一个<strong>封闭作用域</strong>。代码块内，在<strong>声明变量之前</strong>使用它会<strong>报错</strong>，称为<strong>暂时性死区</strong>。 <code>ES6</code>的块级作用域必须有大括号，如果没有大括号，<code>JavaScript</code>引擎就认为不存在块级作用域。</p>\n<ul>\n<li><code>let</code>和<code>const</code>只能声明一次，<code>var</code>可以声明多次。</li>\n<li><code>var</code>会变量提升，<code>let</code>与<code>const</code>也存在变量提升但有所不同。</li>\n<li><code>const</code>声明一个只读的常量，一旦声明，常量的值就不能改变。</li>\n<li><code>const</code>和<code>let</code>在全局作用域中声明的变量不会挂载到<code>window</code>上。</li>\n<li><code>let</code>和<code>const</code>声明的变量只在其声明所在的代码块内有效，形成块级作用域。</li>\n<li><code>const</code>其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。对于基本数据类型<code>number、string 、boolean</code>等，值就保存在变量指向的那个内存地址，因此<code>const</code> 声明的简单类型变量等同于常量。而引用类型<code>object，array，function</code>等，变量指向的内存地址其实是保存了一个指向实际数据的指针，所以<code>const</code>只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了。</li>\n</ul>\n<h2 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h2><p><code>ES6</code>允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">let [a, b, c] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-regexp\">//</span> 基本<br>let [a, [[b], c]] = [<span class=\"hljs-number\">1</span>, [[<span class=\"hljs-number\">2</span>], <span class=\"hljs-number\">3</span>]]; <span class=\"hljs-regexp\">//</span>嵌套<br>let [a, , b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-regexp\">//</span> 可忽略<br>let [a = <span class=\"hljs-number\">1</span>, b] = []; <span class=\"hljs-regexp\">//</span> a = <span class=\"hljs-number\">1</span>, b = undefined <span class=\"hljs-regexp\">//</span> 不完全解构<br>let [a, ...b] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-regexp\">//</span> 剩余运算符<br>let [a, b, c, d, e] = <span class=\"hljs-string\">&#x27;hello&#x27;</span>; <span class=\"hljs-regexp\">//</span> 字符串等<br>let &#123; a, b &#125; = &#123; a: <span class=\"hljs-string\">&#x27;aaa&#x27;</span>, b: <span class=\"hljs-string\">&#x27;bbb&#x27;</span> &#125;; <span class=\"hljs-regexp\">//</span> 对象模型的解构 前后两个kay需对应<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h2><p><code>ES6</code>引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 <code>ES6</code>数据类型除了<code>Number</code>、<code>String</code>、<code>Boolean</code>、 <code>Object</code>、<code>null</code>和<code>undefined</code>，还新增了 <code>Symbol</code>。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">let s1 <span class=\"hljs-operator\">=</span> Symbol(<span class=\"hljs-string\">&quot;s&quot;</span>)<span class=\"hljs-comment\">;</span><br>let s2 <span class=\"hljs-operator\">=</span> Symbol(<span class=\"hljs-string\">&quot;s&quot;</span>)<span class=\"hljs-comment\">;</span><br>console.log(s1 <span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span> s2)<span class=\"hljs-comment\">; //false</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Spread-x2F-Rest-操作符\"><a href=\"#Spread-x2F-Rest-操作符\" class=\"headerlink\" title=\"Spread &#x2F; Rest 操作符\"></a>Spread &#x2F; Rest 操作符</h2><p><code>Spread</code> 用于将数组作为参数直接传入函数。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> s = [<span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-string\">&#x27;3&#x27;</span>];<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">s1,s2,s3</span>)&#123;<br>    <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">$&#123;s1&#125;</span>,<span class=\"hljs-subst\">$&#123;s2&#125;</span>,<span class=\"hljs-subst\">$&#123;s3&#125;</span>`</span>); <span class=\"hljs-comment\">//ES6新增字符串中加入变量和表达式</span><br>&#125;<br>f(...s); <span class=\"hljs-comment\">//Hello 1,2,3</span><br></code></pre></td></tr></table></figure>\n\n<p><code>Rest</code> 用于函数传参传递数组。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">f</span><span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span>&#123;<br>    console.log(args);<br>&#125;<br>f(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">//[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p><code>ES6</code>中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 <code>=&gt;</code>，紧接着是函数体，特别需要注意的是箭头函数是继承当前上下文的<code>this</code>关键字。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">var</span> add = <span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b;<br><span class=\"hljs-keyword\">var</span> show = <span class=\"hljs-function\"><span class=\"hljs-params\">a</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(a);<br><span class=\"hljs-keyword\">var</span> test = <span class=\"hljs-function\">(<span class=\"hljs-params\">a,b,c</span>) =&gt;</span> &#123;<span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(a,b,c);<span class=\"hljs-keyword\">return</span> a+b+c;&#125;<br>add(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//2</span><br>show(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//1</span><br>test(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">//1 1 1</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scss\">function <span class=\"hljs-built_in\">f</span>(a = <span class=\"hljs-number\">1</span>)&#123;<br>    console<span class=\"hljs-selector-class\">.log</span>(a);<br>&#125;<br><span class=\"hljs-built_in\">f</span>(); <span class=\"hljs-comment\">//1</span><br><span class=\"hljs-built_in\">f</span>(<span class=\"hljs-number\">11</span>); <span class=\"hljs-comment\">//11</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h2><ul>\n<li><code>Symbol.iterator</code> 一个统一的接口，它的作用是使各种数据结构可被便捷的访问。</li>\n<li>for of 是 ES6 新引入的循环，用于替代 <code>for..in</code> 和 <code>forEach()</code>。</li>\n</ul>\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p><code>ES6</code>提供了更接近传统语言的写法，引入了<code>class</code>这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类，与多数传统语言类似。不过，<code>ES6</code>的<code>class</code>不是新的对象继承模型，它只是原型链的语法糖表现形式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Me</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;constructor&quot;</span>);<br>  &#125;<br>  <span class=\"hljs-title function_\">study</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;study&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-title class_\">Me</span>); <span class=\"hljs-comment\">//function</span><br><span class=\"hljs-keyword\">let</span> me = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Me</span>(); <span class=\"hljs-comment\">//constructor</span><br>me.<span class=\"hljs-title function_\">study</span>(); <span class=\"hljs-comment\">//study</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-对象\"><a href=\"#Promise-对象\" class=\"headerlink\" title=\"Promise 对象\"></a>Promise 对象</h2><p><code>Promise</code>是异步编程的一种解决方案。</p>\n<p>从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<br>Promise异步操作有三种状态：<code>pending</code>、<code>fulfilled</code>和<code>rejected</code>。除了异步操作的结果，任何其他操作都无法改变这个状态。<br><code>then</code>方法接收两个函数作为参数，第一个参数是<code>Promise</code>执行成功时的回调，第二个参数是 <code>Promise</code>执行失败时的回调，两个函数只会有一个被调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>    <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;resolve&#x27;</span>);<br>&#125;); <br><span class=\"hljs-keyword\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)&#123;<br>    <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-string\">&#x27;reject&#x27;</span>);<br>&#125;);<br>p1.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>)&#123;  <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v); <span class=\"hljs-comment\">//resolve</span><br>&#125;);<br>p2.<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>)&#123; <br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v);<br>&#125;,<br><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">v</span>)&#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(v); <span class=\"hljs-comment\">//reject</span><br>&#125;);<br><br></code></pre></td></tr></table></figure>"},{"title":"原型与原型链","date":"2023-04-13T09:21:44.000Z","_content":"\n# 原型与原型链\n\n原型和原型链又是`js`中最重要的点之一，从`jQuery`到现在最火的框架之一`Vue`，原型的应用无处不在，那我们该怎么学好`JavaScript`的原型和原型链呢？首先我们来看一张图。\n\n{% asset_img img.png 原型链 %}\n\n+ 想要弄清楚原型和原型链，这几个属性必须要搞清楚，`__proto__`、`prototype`、 `constructor`\n+ 其次你要知道`js`中对象和函数的关系，函数其实是对象的一种。\n+ 最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。\n\n```\nvar Parent = function(){\n\n}\n//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通\nvar p1 = new Parent();\n//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它\n//创建了一个Parent构造函数的实例 p1\n```\n\n如果到这你都能理解，我们再引出一个概念，开始说过了要想清楚原型就要先搞清楚这三个属性，`__proto__`、`prototype`、 `constructor`。\n\n+ `__proto__`、 `constructor`属性是对象所独有的；\n+ `prototype`属性是函数独有的；\n+ 上面说过`js`中函数也是对象的一种，那么函数同样也有属性`__proto__`、 `constructor`；\n\n下面开始进入正题，我将上面的一张图拆分成3张图，分别讲解对应的3个属性。\n\n## prototype属性\n\n>为了方便举例，我们在这模拟一个场景，父类比作师父，子类比作徒弟。师父收徒弟，\n徒弟还可以收徒弟。徒弟可以得到师父传授的武功，然后徒弟再传给自己的徒弟。\n师父想要传授给徒弟们的武功就放到`prototype`这个琅琊福地中。徒弟徒孙们就去这里学习武功。\n>\n>`prototype`属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法和属性。\n\n{% asset_img img_1.png prototype %}\n\n它是函数独有的属性，从图中可以看到它从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。\n\n`prototype`设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了`prototype`我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（`prototype`）。那些不需要共享的才创建在构造函数中。\n\n继续引用上面的代码，当我们想为通过`Parent`实例化的所有实例添加一个共享的属性时，\n\n```\nParent.prototype.name = \"我是原型属性，所有实例都可以读取到我\";\n```\n\n这就是原型属性，当然你也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓\n\n## proto属性\n\n>`__proto__`属性相当于通往`prototype`（“琅琊福地”）唯一的路（指针）\n让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性\n\n{% asset_img img_2.png __proto__ %}\n\n`__proto__`属性是对象（包括函数）独有的。从图中可以看到`__proto__`属性是从一个对象指向另一个对象，即从一个对象指向该对象的原型对象（也可以理解为父对象）。显然它的含义就是告诉我们一个对象的原型对象是谁。\n\n`prototype`篇章我们说到，`Parent.prototype`上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型对象上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过`__proto__`属性。每个对象都有`__proto__`属性，该属性指向的就是该对象的原型对象。\n\n```\np1.__proto__ === Parent.prototype; // true\n```\n\n`__proto__`通常称为隐式原型，`prototype`通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。\n\n我们之前也说过`__proto__`属性是对象（包括函数）独有的，那么`Parent.prototype`也是对象，那它有隐式原型么？又指向谁？\n\n```\nParent.prototype.__proto__ === Object.prototype; //true\n```\n\n可以看到，构造函数的原型对象上的隐式原型对象指向了`Object`的原型对象。那么`Parent`的原型对象就继承了`Object`的原型对象。由此我们可以验证一个结论，万物继承自`Object.prototype`。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如：\n\n```\n//我们并没有在Parent中定义任何方法属性，但是我们可以调用\np1.toString();//hasOwnProperty 等等的一些方法\n```\n\n我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用`p1.toString()`的时候，先在`p1`对象本身寻找，没有找到则通过`p1.__proto__`找到了原型对象`Parent.prototype`，也没有找到，又通过`Parent.prototype.__proto__`找到了上一层原型对象`Object.prototype`。在这一层找到了`toString`方法。返回该方法供p1使用。\n当然如果找到`Object.prototype`上也没找到，就在`Object.prototype.__proto__`中寻找，但是`Object.prototype.__proto__ === null`所以就返回`undefined`。这就是为什么当访问对象中一个不存在的属性时，返回`undefined`了。\n\n## constructor属性\n\n>constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己，这里可不是“师父”啊\n>\n>而是自己的父母，父母创造了自己，父母又是由上一辈人创造的，……追溯到头就是Function() 【女娲】。\n>\n\n\n{% asset_img img_3.png constructor %}\n\n\n`constructor`是对象才有的属性，从图中看到它是从一个对象指向一个函数的。指向的函数就是该对象的构造函数。每个对象都有构造函数，好比我们上面的代码`p1`就是一个对象，那p1的构造函数是谁呢？我们打印一下。\n\n```\nconsole.log(p1.constructor); // ƒ Parent(){}\n```\n\n通过输出结果看到，很显然是`Parent`函数。我们有说过函数也是对象，那`Parent`函数是不是也有构造函数呢？显然是有的。再次打印下。\n\n```\nconsole.log(Parent.constructor); // ƒ Function() { [native code] }\n```\n\n通过输出看到`Parent`函数的构造函数是`Function()`，这点也不奇怪，因为我们每次定义函数其实都是调用了`new Function()`，下面两种效果是一样的。\n\n```\nvar fn1 = new Function('msg','alert(msg)');\nfunction fn1(msg){\n    alert(msg);\n}\n```\n\n那么我们再回来看下，再次打印`Function.constructor`\n\n```\nconsole.log(Function.constructor); // ƒ Function() { [native code] }\n```\n\n可以看到`Function`函数的构造函数就是本身了，那我们也就可以说`Function`是所有函数的根构造函数。\n到这里我们已经对`constructor`属性有了一个初步的认识，它的作用是从一个对象指向一个函数，这个函数就是该对象的构造函数。通过栗子我们可以看到，`p1`的`constructor`属性指向了`Parent`，那么`Parent`就是`p1`的构造函数。同样`Parent`的`constructor`属性指向了`Function`，那么`Function`就是`Parent`的构造函数，然后又验证了`Function`就是根构造函数。\n\n\n\n>值得注意的是 `typeof (null)` 会返回 `Object` ，这是因为 `JS` 二进制前三位都为0的话会被判断为 `Object` 类型，`null` 的二进制表示是全0，自然前三位也是0，所以执行 `typeof` 时会返回 `Object`，实际 `null` 为基本数据类型。\n\n\n","source":"_posts/Javascript/原型与原型链.md","raw":"---\ntitle: 原型与原型链\ntags:\n  - javascript\n  - es6\ncategories:\n  - Javascript\ndate: 2023-04-13 17:21:44\n---\n\n# 原型与原型链\n\n原型和原型链又是`js`中最重要的点之一，从`jQuery`到现在最火的框架之一`Vue`，原型的应用无处不在，那我们该怎么学好`JavaScript`的原型和原型链呢？首先我们来看一张图。\n\n{% asset_img img.png 原型链 %}\n\n+ 想要弄清楚原型和原型链，这几个属性必须要搞清楚，`__proto__`、`prototype`、 `constructor`\n+ 其次你要知道`js`中对象和函数的关系，函数其实是对象的一种。\n+ 最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。\n\n```\nvar Parent = function(){\n\n}\n//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通\nvar p1 = new Parent();\n//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它\n//创建了一个Parent构造函数的实例 p1\n```\n\n如果到这你都能理解，我们再引出一个概念，开始说过了要想清楚原型就要先搞清楚这三个属性，`__proto__`、`prototype`、 `constructor`。\n\n+ `__proto__`、 `constructor`属性是对象所独有的；\n+ `prototype`属性是函数独有的；\n+ 上面说过`js`中函数也是对象的一种，那么函数同样也有属性`__proto__`、 `constructor`；\n\n下面开始进入正题，我将上面的一张图拆分成3张图，分别讲解对应的3个属性。\n\n## prototype属性\n\n>为了方便举例，我们在这模拟一个场景，父类比作师父，子类比作徒弟。师父收徒弟，\n徒弟还可以收徒弟。徒弟可以得到师父传授的武功，然后徒弟再传给自己的徒弟。\n师父想要传授给徒弟们的武功就放到`prototype`这个琅琊福地中。徒弟徒孙们就去这里学习武功。\n>\n>`prototype`属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法和属性。\n\n{% asset_img img_1.png prototype %}\n\n它是函数独有的属性，从图中可以看到它从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。\n\n`prototype`设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了`prototype`我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（`prototype`）。那些不需要共享的才创建在构造函数中。\n\n继续引用上面的代码，当我们想为通过`Parent`实例化的所有实例添加一个共享的属性时，\n\n```\nParent.prototype.name = \"我是原型属性，所有实例都可以读取到我\";\n```\n\n这就是原型属性，当然你也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓\n\n## proto属性\n\n>`__proto__`属性相当于通往`prototype`（“琅琊福地”）唯一的路（指针）\n让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性\n\n{% asset_img img_2.png __proto__ %}\n\n`__proto__`属性是对象（包括函数）独有的。从图中可以看到`__proto__`属性是从一个对象指向另一个对象，即从一个对象指向该对象的原型对象（也可以理解为父对象）。显然它的含义就是告诉我们一个对象的原型对象是谁。\n\n`prototype`篇章我们说到，`Parent.prototype`上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型对象上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过`__proto__`属性。每个对象都有`__proto__`属性，该属性指向的就是该对象的原型对象。\n\n```\np1.__proto__ === Parent.prototype; // true\n```\n\n`__proto__`通常称为隐式原型，`prototype`通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。\n\n我们之前也说过`__proto__`属性是对象（包括函数）独有的，那么`Parent.prototype`也是对象，那它有隐式原型么？又指向谁？\n\n```\nParent.prototype.__proto__ === Object.prototype; //true\n```\n\n可以看到，构造函数的原型对象上的隐式原型对象指向了`Object`的原型对象。那么`Parent`的原型对象就继承了`Object`的原型对象。由此我们可以验证一个结论，万物继承自`Object.prototype`。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如：\n\n```\n//我们并没有在Parent中定义任何方法属性，但是我们可以调用\np1.toString();//hasOwnProperty 等等的一些方法\n```\n\n我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用`p1.toString()`的时候，先在`p1`对象本身寻找，没有找到则通过`p1.__proto__`找到了原型对象`Parent.prototype`，也没有找到，又通过`Parent.prototype.__proto__`找到了上一层原型对象`Object.prototype`。在这一层找到了`toString`方法。返回该方法供p1使用。\n当然如果找到`Object.prototype`上也没找到，就在`Object.prototype.__proto__`中寻找，但是`Object.prototype.__proto__ === null`所以就返回`undefined`。这就是为什么当访问对象中一个不存在的属性时，返回`undefined`了。\n\n## constructor属性\n\n>constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己，这里可不是“师父”啊\n>\n>而是自己的父母，父母创造了自己，父母又是由上一辈人创造的，……追溯到头就是Function() 【女娲】。\n>\n\n\n{% asset_img img_3.png constructor %}\n\n\n`constructor`是对象才有的属性，从图中看到它是从一个对象指向一个函数的。指向的函数就是该对象的构造函数。每个对象都有构造函数，好比我们上面的代码`p1`就是一个对象，那p1的构造函数是谁呢？我们打印一下。\n\n```\nconsole.log(p1.constructor); // ƒ Parent(){}\n```\n\n通过输出结果看到，很显然是`Parent`函数。我们有说过函数也是对象，那`Parent`函数是不是也有构造函数呢？显然是有的。再次打印下。\n\n```\nconsole.log(Parent.constructor); // ƒ Function() { [native code] }\n```\n\n通过输出看到`Parent`函数的构造函数是`Function()`，这点也不奇怪，因为我们每次定义函数其实都是调用了`new Function()`，下面两种效果是一样的。\n\n```\nvar fn1 = new Function('msg','alert(msg)');\nfunction fn1(msg){\n    alert(msg);\n}\n```\n\n那么我们再回来看下，再次打印`Function.constructor`\n\n```\nconsole.log(Function.constructor); // ƒ Function() { [native code] }\n```\n\n可以看到`Function`函数的构造函数就是本身了，那我们也就可以说`Function`是所有函数的根构造函数。\n到这里我们已经对`constructor`属性有了一个初步的认识，它的作用是从一个对象指向一个函数，这个函数就是该对象的构造函数。通过栗子我们可以看到，`p1`的`constructor`属性指向了`Parent`，那么`Parent`就是`p1`的构造函数。同样`Parent`的`constructor`属性指向了`Function`，那么`Function`就是`Parent`的构造函数，然后又验证了`Function`就是根构造函数。\n\n\n\n>值得注意的是 `typeof (null)` 会返回 `Object` ，这是因为 `JS` 二进制前三位都为0的话会被判断为 `Object` 类型，`null` 的二进制表示是全0，自然前三位也是0，所以执行 `typeof` 时会返回 `Object`，实际 `null` 为基本数据类型。\n\n\n","slug":"Javascript/原型与原型链","published":1,"updated":"2023-04-13T09:54:44.498Z","_id":"clgey0sex000afpc37zgf6i0g","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"原型与原型链\"><a href=\"#原型与原型链\" class=\"headerlink\" title=\"原型与原型链\"></a>原型与原型链</h1><p>原型和原型链又是<code>js</code>中最重要的点之一，从<code>jQuery</code>到现在最火的框架之一<code>Vue</code>，原型的应用无处不在，那我们该怎么学好<code>JavaScript</code>的原型和原型链呢？首先我们来看一张图。</p>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img.png\" class=\"\" title=\"原型链\">\n\n<ul>\n<li>想要弄清楚原型和原型链，这几个属性必须要搞清楚，<code>__proto__</code>、<code>prototype</code>、 <code>constructor</code></li>\n<li>其次你要知道<code>js</code>中对象和函数的关系，函数其实是对象的一种。</li>\n<li>最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。</li>\n</ul>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">var</span> Parent = <span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>&#123;<br><br>&#125;<br><span class=\"hljs-comment\">//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通</span><br><span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-keyword\">new</span> Parent();<br><span class=\"hljs-comment\">//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它</span><br><span class=\"hljs-comment\">//创建了一个Parent构造函数的实例 p1</span><br></code></pre></td></tr></table></figure>\n\n<p>如果到这你都能理解，我们再引出一个概念，开始说过了要想清楚原型就要先搞清楚这三个属性，<code>__proto__</code>、<code>prototype</code>、 <code>constructor</code>。</p>\n<ul>\n<li><code>__proto__</code>、 <code>constructor</code>属性是对象所独有的；</li>\n<li><code>prototype</code>属性是函数独有的；</li>\n<li>上面说过<code>js</code>中函数也是对象的一种，那么函数同样也有属性<code>__proto__</code>、 <code>constructor</code>；</li>\n</ul>\n<p>下面开始进入正题，我将上面的一张图拆分成3张图，分别讲解对应的3个属性。</p>\n<h2 id=\"prototype属性\"><a href=\"#prototype属性\" class=\"headerlink\" title=\"prototype属性\"></a>prototype属性</h2><blockquote>\n<p>为了方便举例，我们在这模拟一个场景，父类比作师父，子类比作徒弟。师父收徒弟，<br>徒弟还可以收徒弟。徒弟可以得到师父传授的武功，然后徒弟再传给自己的徒弟。<br>师父想要传授给徒弟们的武功就放到<code>prototype</code>这个琅琊福地中。徒弟徒孙们就去这里学习武功。</p>\n<p><code>prototype</code>属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法和属性。</p>\n</blockquote>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img_1.png\" class=\"\" title=\"prototype\">\n\n<p>它是函数独有的属性，从图中可以看到它从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。</p>\n<p><code>prototype</code>设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了<code>prototype</code>我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（<code>prototype</code>）。那些不需要共享的才创建在构造函数中。</p>\n<p>继续引用上面的代码，当我们想为通过<code>Parent</code>实例化的所有实例添加一个共享的属性时，</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">Parent.prototype.name</span> = <span class=\"hljs-string\">&quot;我是原型属性，所有实例都可以读取到我&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>这就是原型属性，当然你也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓</p>\n<h2 id=\"proto属性\"><a href=\"#proto属性\" class=\"headerlink\" title=\"proto属性\"></a>proto属性</h2><blockquote>\n<p><code>__proto__</code>属性相当于通往<code>prototype</code>（“琅琊福地”）唯一的路（指针）<br>让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性</p>\n</blockquote>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img_2.png\" class=\"\" title=\"__proto__\">\n\n<p><code>__proto__</code>属性是对象（包括函数）独有的。从图中可以看到<code>__proto__</code>属性是从一个对象指向另一个对象，即从一个对象指向该对象的原型对象（也可以理解为父对象）。显然它的含义就是告诉我们一个对象的原型对象是谁。</p>\n<p><code>prototype</code>篇章我们说到，<code>Parent.prototype</code>上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型对象上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过<code>__proto__</code>属性。每个对象都有<code>__proto__</code>属性，该属性指向的就是该对象的原型对象。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">p1.__proto__ <span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span> Parent.prototype<span class=\"hljs-comment\">; // true</span><br></code></pre></td></tr></table></figure>\n\n<p><code>__proto__</code>通常称为隐式原型，<code>prototype</code>通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。</p>\n<p>我们之前也说过<code>__proto__</code>属性是对象（包括函数）独有的，那么<code>Parent.prototype</code>也是对象，那它有隐式原型么？又指向谁？</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">Parent.prototype.__proto__ <span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span> Object.prototype<span class=\"hljs-comment\">; //true</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，构造函数的原型对象上的隐式原型对象指向了<code>Object</code>的原型对象。那么<code>Parent</code>的原型对象就继承了<code>Object</code>的原型对象。由此我们可以验证一个结论，万物继承自<code>Object.prototype</code>。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span>我们并没有在Parent中定义任何方法属性，但是我们可以调用<br>p1.toString();<span class=\"hljs-regexp\">//</span>hasOwnProperty 等等的一些方法<br></code></pre></td></tr></table></figure>\n\n<p>我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用<code>p1.toString()</code>的时候，先在<code>p1</code>对象本身寻找，没有找到则通过<code>p1.__proto__</code>找到了原型对象<code>Parent.prototype</code>，也没有找到，又通过<code>Parent.prototype.__proto__</code>找到了上一层原型对象<code>Object.prototype</code>。在这一层找到了<code>toString</code>方法。返回该方法供p1使用。<br>当然如果找到<code>Object.prototype</code>上也没找到，就在<code>Object.prototype.__proto__</code>中寻找，但是<code>Object.prototype.__proto__ === null</code>所以就返回<code>undefined</code>。这就是为什么当访问对象中一个不存在的属性时，返回<code>undefined</code>了。</p>\n<h2 id=\"constructor属性\"><a href=\"#constructor属性\" class=\"headerlink\" title=\"constructor属性\"></a>constructor属性</h2><blockquote>\n<p>constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己，这里可不是“师父”啊</p>\n<p>而是自己的父母，父母创造了自己，父母又是由上一辈人创造的，……追溯到头就是Function() 【女娲】。</p>\n</blockquote>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img_3.png\" class=\"\" title=\"constructor\">\n\n\n<p><code>constructor</code>是对象才有的属性，从图中看到它是从一个对象指向一个函数的。指向的函数就是该对象的构造函数。每个对象都有构造函数，好比我们上面的代码<code>p1</code>就是一个对象，那p1的构造函数是谁呢？我们打印一下。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(p1.constructor); <span class=\"hljs-comment\">// ƒ Parent()&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过输出结果看到，很显然是<code>Parent</code>函数。我们有说过函数也是对象，那<code>Parent</code>函数是不是也有构造函数呢？显然是有的。再次打印下。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(Parent.constructor); <span class=\"hljs-comment\">// ƒ Function() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过输出看到<code>Parent</code>函数的构造函数是<code>Function()</code>，这点也不奇怪，因为我们每次定义函数其实都是调用了<code>new Function()</code>，下面两种效果是一样的。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-keyword\">var</span> fn1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Function</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;msg&#x27;</span>,<span class=\"hljs-string\">&#x27;alert(msg)&#x27;</span>)</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn1</span><span class=\"hljs-params\">(msg)</span><span class=\"hljs-comment\">&#123;</span><br><span class=\"hljs-comment\">    alert(msg);</span><br><span class=\"hljs-comment\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>那么我们再回来看下，再次打印<code>Function.constructor</code></p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-keyword\">Function</span>.constructor); <span class=\"hljs-comment\">// ƒ Function() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到<code>Function</code>函数的构造函数就是本身了，那我们也就可以说<code>Function</code>是所有函数的根构造函数。<br>到这里我们已经对<code>constructor</code>属性有了一个初步的认识，它的作用是从一个对象指向一个函数，这个函数就是该对象的构造函数。通过栗子我们可以看到，<code>p1</code>的<code>constructor</code>属性指向了<code>Parent</code>，那么<code>Parent</code>就是<code>p1</code>的构造函数。同样<code>Parent</code>的<code>constructor</code>属性指向了<code>Function</code>，那么<code>Function</code>就是<code>Parent</code>的构造函数，然后又验证了<code>Function</code>就是根构造函数。</p>\n<blockquote>\n<p>值得注意的是 <code>typeof (null)</code> 会返回 <code>Object</code> ，这是因为 <code>JS</code> 二进制前三位都为0的话会被判断为 <code>Object</code> 类型，<code>null</code> 的二进制表示是全0，自然前三位也是0，所以执行 <code>typeof</code> 时会返回 <code>Object</code>，实际 <code>null</code> 为基本数据类型。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"原型与原型链\"><a href=\"#原型与原型链\" class=\"headerlink\" title=\"原型与原型链\"></a>原型与原型链</h1><p>原型和原型链又是<code>js</code>中最重要的点之一，从<code>jQuery</code>到现在最火的框架之一<code>Vue</code>，原型的应用无处不在，那我们该怎么学好<code>JavaScript</code>的原型和原型链呢？首先我们来看一张图。</p>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img.png\" class=\"\" title=\"原型链\">\n\n<ul>\n<li>想要弄清楚原型和原型链，这几个属性必须要搞清楚，<code>__proto__</code>、<code>prototype</code>、 <code>constructor</code></li>\n<li>其次你要知道<code>js</code>中对象和函数的关系，函数其实是对象的一种。</li>\n<li>最后你要知道函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。</li>\n</ul>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs actionscript\"><span class=\"hljs-keyword\">var</span> Parent = <span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span>&#123;<br><br>&#125;<br><span class=\"hljs-comment\">//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通</span><br><span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-keyword\">new</span> Parent();<br><span class=\"hljs-comment\">//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它</span><br><span class=\"hljs-comment\">//创建了一个Parent构造函数的实例 p1</span><br></code></pre></td></tr></table></figure>\n\n<p>如果到这你都能理解，我们再引出一个概念，开始说过了要想清楚原型就要先搞清楚这三个属性，<code>__proto__</code>、<code>prototype</code>、 <code>constructor</code>。</p>\n<ul>\n<li><code>__proto__</code>、 <code>constructor</code>属性是对象所独有的；</li>\n<li><code>prototype</code>属性是函数独有的；</li>\n<li>上面说过<code>js</code>中函数也是对象的一种，那么函数同样也有属性<code>__proto__</code>、 <code>constructor</code>；</li>\n</ul>\n<p>下面开始进入正题，我将上面的一张图拆分成3张图，分别讲解对应的3个属性。</p>\n<h2 id=\"prototype属性\"><a href=\"#prototype属性\" class=\"headerlink\" title=\"prototype属性\"></a>prototype属性</h2><blockquote>\n<p>为了方便举例，我们在这模拟一个场景，父类比作师父，子类比作徒弟。师父收徒弟，<br>徒弟还可以收徒弟。徒弟可以得到师父传授的武功，然后徒弟再传给自己的徒弟。<br>师父想要传授给徒弟们的武功就放到<code>prototype</code>这个琅琊福地中。徒弟徒孙们就去这里学习武功。</p>\n<p><code>prototype</code>属性可以看成是一块特殊的存储空间，存储了供“徒弟”、“徒孙”们使用的方法和属性。</p>\n</blockquote>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img_1.png\" class=\"\" title=\"prototype\">\n\n<p>它是函数独有的属性，从图中可以看到它从一个函数指向另一个对象，代表这个对象是这个函数的原型对象，这个对象也是当前函数所创建的实例的原型对象。</p>\n<p><code>prototype</code>设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了<code>prototype</code>我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（<code>prototype</code>）。那些不需要共享的才创建在构造函数中。</p>\n<p>继续引用上面的代码，当我们想为通过<code>Parent</code>实例化的所有实例添加一个共享的属性时，</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-attr\">Parent.prototype.name</span> = <span class=\"hljs-string\">&quot;我是原型属性，所有实例都可以读取到我&quot;</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<p>这就是原型属性，当然你也可以添加原型方法。那问题来了，p1怎么知道他的原型对象上有这个方法呢，往下看↓↓↓</p>\n<h2 id=\"proto属性\"><a href=\"#proto属性\" class=\"headerlink\" title=\"proto属性\"></a>proto属性</h2><blockquote>\n<p><code>__proto__</code>属性相当于通往<code>prototype</code>（“琅琊福地”）唯一的路（指针）<br>让“徒弟”、“徒孙” 们找到自己“师父”、“师父的师父” 提供给自己的方法和属性</p>\n</blockquote>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img_2.png\" class=\"\" title=\"__proto__\">\n\n<p><code>__proto__</code>属性是对象（包括函数）独有的。从图中可以看到<code>__proto__</code>属性是从一个对象指向另一个对象，即从一个对象指向该对象的原型对象（也可以理解为父对象）。显然它的含义就是告诉我们一个对象的原型对象是谁。</p>\n<p><code>prototype</code>篇章我们说到，<code>Parent.prototype</code>上添加的属性和方法叫做原型属性和原型方法，该构造函数的实例都可以访问调用。那这个构造函数的原型对象上的属性和方法，怎么能和构造函数的实例联系在一起呢，就是通过<code>__proto__</code>属性。每个对象都有<code>__proto__</code>属性，该属性指向的就是该对象的原型对象。</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">p1.__proto__ <span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span> Parent.prototype<span class=\"hljs-comment\">; // true</span><br></code></pre></td></tr></table></figure>\n\n<p><code>__proto__</code>通常称为隐式原型，<code>prototype</code>通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。</p>\n<p>我们之前也说过<code>__proto__</code>属性是对象（包括函数）独有的，那么<code>Parent.prototype</code>也是对象，那它有隐式原型么？又指向谁？</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs abnf\">Parent.prototype.__proto__ <span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span><span class=\"hljs-operator\">=</span> Object.prototype<span class=\"hljs-comment\">; //true</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，构造函数的原型对象上的隐式原型对象指向了<code>Object</code>的原型对象。那么<code>Parent</code>的原型对象就继承了<code>Object</code>的原型对象。由此我们可以验证一个结论，万物继承自<code>Object.prototype</code>。这也就是为什么我们可以实例化一个对象，并且可以调用该对象上没有的属性和方法了。如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span>我们并没有在Parent中定义任何方法属性，但是我们可以调用<br>p1.toString();<span class=\"hljs-regexp\">//</span>hasOwnProperty 等等的一些方法<br></code></pre></td></tr></table></figure>\n\n<p>我们可以调用很多我们没有定义的方法，这些方法是哪来的呢？现在引出原型链的概念，当我们调用<code>p1.toString()</code>的时候，先在<code>p1</code>对象本身寻找，没有找到则通过<code>p1.__proto__</code>找到了原型对象<code>Parent.prototype</code>，也没有找到，又通过<code>Parent.prototype.__proto__</code>找到了上一层原型对象<code>Object.prototype</code>。在这一层找到了<code>toString</code>方法。返回该方法供p1使用。<br>当然如果找到<code>Object.prototype</code>上也没找到，就在<code>Object.prototype.__proto__</code>中寻找，但是<code>Object.prototype.__proto__ === null</code>所以就返回<code>undefined</code>。这就是为什么当访问对象中一个不存在的属性时，返回<code>undefined</code>了。</p>\n<h2 id=\"constructor属性\"><a href=\"#constructor属性\" class=\"headerlink\" title=\"constructor属性\"></a>constructor属性</h2><blockquote>\n<p>constructor属性是让“徒弟”、“徒孙” 们知道是谁创造了自己，这里可不是“师父”啊</p>\n<p>而是自己的父母，父母创造了自己，父母又是由上一辈人创造的，……追溯到头就是Function() 【女娲】。</p>\n</blockquote>\n<img src=\"/2023/04/13/Javascript/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/img_3.png\" class=\"\" title=\"constructor\">\n\n\n<p><code>constructor</code>是对象才有的属性，从图中看到它是从一个对象指向一个函数的。指向的函数就是该对象的构造函数。每个对象都有构造函数，好比我们上面的代码<code>p1</code>就是一个对象，那p1的构造函数是谁呢？我们打印一下。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(p1.constructor); <span class=\"hljs-comment\">// ƒ Parent()&#123;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过输出结果看到，很显然是<code>Parent</code>函数。我们有说过函数也是对象，那<code>Parent</code>函数是不是也有构造函数呢？显然是有的。再次打印下。</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(Parent.constructor); <span class=\"hljs-comment\">// ƒ Function() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>通过输出看到<code>Parent</code>函数的构造函数是<code>Function()</code>，这点也不奇怪，因为我们每次定义函数其实都是调用了<code>new Function()</code>，下面两种效果是一样的。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\"><span class=\"hljs-keyword\">var</span> fn1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Function</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&#x27;msg&#x27;</span>,<span class=\"hljs-string\">&#x27;alert(msg)&#x27;</span>)</span>;<br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn1</span><span class=\"hljs-params\">(msg)</span><span class=\"hljs-comment\">&#123;</span><br><span class=\"hljs-comment\">    alert(msg);</span><br><span class=\"hljs-comment\">&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>那么我们再回来看下，再次打印<code>Function.constructor</code></p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-keyword\">Function</span>.constructor); <span class=\"hljs-comment\">// ƒ Function() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到<code>Function</code>函数的构造函数就是本身了，那我们也就可以说<code>Function</code>是所有函数的根构造函数。<br>到这里我们已经对<code>constructor</code>属性有了一个初步的认识，它的作用是从一个对象指向一个函数，这个函数就是该对象的构造函数。通过栗子我们可以看到，<code>p1</code>的<code>constructor</code>属性指向了<code>Parent</code>，那么<code>Parent</code>就是<code>p1</code>的构造函数。同样<code>Parent</code>的<code>constructor</code>属性指向了<code>Function</code>，那么<code>Function</code>就是<code>Parent</code>的构造函数，然后又验证了<code>Function</code>就是根构造函数。</p>\n<blockquote>\n<p>值得注意的是 <code>typeof (null)</code> 会返回 <code>Object</code> ，这是因为 <code>JS</code> 二进制前三位都为0的话会被判断为 <code>Object</code> 类型，<code>null</code> 的二进制表示是全0，自然前三位也是0，所以执行 <code>typeof</code> 时会返回 <code>Object</code>，实际 <code>null</code> 为基本数据类型。</p>\n</blockquote>\n"},{"title":"CSS overflow-anchor属性的一些坑","date":"2023-04-13T09:45:31.000Z","_content":"\n# CSS overflow-anchor属性的一些坑\n\n之前在做虚拟滚动组件，但是在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。\n\n大家都知道，比较常用的虚拟滚动就是只显示中间用户能够看的见的值，其余用户看不见的值，就填充空白的div以优化性能。\n\n![image](https://user-images.githubusercontent.com/2912039/230706172-d81bb2ca-06d4-4a57-9c1a-7e97d5ae36c8.png)\n\n但是这次在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。\n\n## 什么是滚动锚定\n\n滚动锚定是一种浏览器功能，它是用来防止你在 DOM 完全加载之前向下滚动网页的常见情况，如果没有滚动锚定，你所看到的内容就会一直被往下推。大家可能有过这样的浏览体验，就是图片很多的时候，例如漫画网站，在手机端，垂直布局这种，如果上方的图片加载慢，那么下方的图片看着看着就会被推下来，然后自己又要重新去滚动定位。\n\n这是一个不太友好的浏览器体验行为。 于是，Chrome 56（2017年）和Firefox 66（2019年）开始，这些浏览器就对滚动行为进行了优化，实现了一种“滚动锚定”的交互行为。 具体描述为：当前视区上面的内容突然出现的时候，浏览器自动改变滚动高度，让视区窗口区域内容固定，就像滚动效果被锚定一样。\n\n因此，在PC端，在Chrome浏览器下和Firefox浏览器下，当你浏览网页的时候，是感觉不到页面跳动的，就是滚动锚定在其作用。\n\n## overflow-anchor属性\n\noverflow-anchor属性的值非常简单，它接受两个值，它们本质上切换是否启用该功能。\n\n```\noverflow-anchor: [ auto | none ];\n```\n\nauto（默认）：在页面或元素应用它的部分启用滚动锚定。\n\nnone：禁用部分或全部网页的滚动锚定，或将 DOM 的一部分排除在锚定之外，从而允许内容重排。\n\noverflow-anchor属性可以放在body中对全局生效，也可以单独放在某个元素中，对部分页面元素起作用。\n\n## 应用案例\n\n下面我们看看具体应用到元素中会有什么不同，下面的案例是实时效果，大家可以直接滚动操作，左边是默认的overflow-anchor:auto，右边设置的是overflow-anchor:none。\n\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/oWgENp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"overflow-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/oWgENp\"> overflow-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n这个属性其实对于很多用户刷新应用都非常有用。 例如，一个聊天应用程序，在这个页面中，新消息会添加到底部的 DOM，如果你希望一直看到最新的消息，这个时候就可以把overflow-anchor设置为none，详细参考下面的demo：\n\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/bGbeBdp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"&quot;Stay at the bottom&quot; scrolling with scroll-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/bGbeBdp\"> &amp;quot;Stay at the bottom&amp;quot; scrolling with scroll-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n## 总结\n\n虽然overflow-anchor属性还不是W3C的标准，但是已经提上了日程，提供了规范的草案报告可供阅读，并且自版本 56 起已被 Chrome 采用。Mozilla 正在考虑在 Firefox 中使用类似的功能。 随着越来越多的浏览器采用滚动锚定功能，我们可能期望看到更多浏览器支持溢出锚定，因为它提供了明确的控制来选择是否使用滚动锚定这个特性。\n\n![image](https://user-images.githubusercontent.com/2912039/230706404-76369b04-886e-4482-94f1-f8df6bdb54dd.png)\n","source":"_posts/Css/CSS-overflow-anchor属性的一些坑.md","raw":"---\ntitle: CSS overflow-anchor属性的一些坑\ntags:\n  - css\ncategories:\n  - Css\ndate: 2023-04-13 17:45:31\n---\n\n# CSS overflow-anchor属性的一些坑\n\n之前在做虚拟滚动组件，但是在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。\n\n大家都知道，比较常用的虚拟滚动就是只显示中间用户能够看的见的值，其余用户看不见的值，就填充空白的div以优化性能。\n\n![image](https://user-images.githubusercontent.com/2912039/230706172-d81bb2ca-06d4-4a57-9c1a-7e97d5ae36c8.png)\n\n但是这次在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。\n\n## 什么是滚动锚定\n\n滚动锚定是一种浏览器功能，它是用来防止你在 DOM 完全加载之前向下滚动网页的常见情况，如果没有滚动锚定，你所看到的内容就会一直被往下推。大家可能有过这样的浏览体验，就是图片很多的时候，例如漫画网站，在手机端，垂直布局这种，如果上方的图片加载慢，那么下方的图片看着看着就会被推下来，然后自己又要重新去滚动定位。\n\n这是一个不太友好的浏览器体验行为。 于是，Chrome 56（2017年）和Firefox 66（2019年）开始，这些浏览器就对滚动行为进行了优化，实现了一种“滚动锚定”的交互行为。 具体描述为：当前视区上面的内容突然出现的时候，浏览器自动改变滚动高度，让视区窗口区域内容固定，就像滚动效果被锚定一样。\n\n因此，在PC端，在Chrome浏览器下和Firefox浏览器下，当你浏览网页的时候，是感觉不到页面跳动的，就是滚动锚定在其作用。\n\n## overflow-anchor属性\n\noverflow-anchor属性的值非常简单，它接受两个值，它们本质上切换是否启用该功能。\n\n```\noverflow-anchor: [ auto | none ];\n```\n\nauto（默认）：在页面或元素应用它的部分启用滚动锚定。\n\nnone：禁用部分或全部网页的滚动锚定，或将 DOM 的一部分排除在锚定之外，从而允许内容重排。\n\noverflow-anchor属性可以放在body中对全局生效，也可以单独放在某个元素中，对部分页面元素起作用。\n\n## 应用案例\n\n下面我们看看具体应用到元素中会有什么不同，下面的案例是实时效果，大家可以直接滚动操作，左边是默认的overflow-anchor:auto，右边设置的是overflow-anchor:none。\n\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/oWgENp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"overflow-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/oWgENp\"> overflow-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n这个属性其实对于很多用户刷新应用都非常有用。 例如，一个聊天应用程序，在这个页面中，新消息会添加到底部的 DOM，如果你希望一直看到最新的消息，这个时候就可以把overflow-anchor设置为none，详细参考下面的demo：\n\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/bGbeBdp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"&quot;Stay at the bottom&quot; scrolling with scroll-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/bGbeBdp\"> &amp;quot;Stay at the bottom&amp;quot; scrolling with scroll-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n## 总结\n\n虽然overflow-anchor属性还不是W3C的标准，但是已经提上了日程，提供了规范的草案报告可供阅读，并且自版本 56 起已被 Chrome 采用。Mozilla 正在考虑在 Firefox 中使用类似的功能。 随着越来越多的浏览器采用滚动锚定功能，我们可能期望看到更多浏览器支持溢出锚定，因为它提供了明确的控制来选择是否使用滚动锚定这个特性。\n\n![image](https://user-images.githubusercontent.com/2912039/230706404-76369b04-886e-4482-94f1-f8df6bdb54dd.png)\n","slug":"Css/CSS-overflow-anchor属性的一些坑","published":1,"updated":"2023-04-13T09:54:44.498Z","_id":"clgey11v4000dfpc32wr41d62","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"CSS-overflow-anchor属性的一些坑\"><a href=\"#CSS-overflow-anchor属性的一些坑\" class=\"headerlink\" title=\"CSS overflow-anchor属性的一些坑\"></a>CSS overflow-anchor属性的一些坑</h1><p>之前在做虚拟滚动组件，但是在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。</p>\n<p>大家都知道，比较常用的虚拟滚动就是只显示中间用户能够看的见的值，其余用户看不见的值，就填充空白的div以优化性能。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230706172-d81bb2ca-06d4-4a57-9c1a-7e97d5ae36c8.png\" alt=\"image\"></p>\n<p>但是这次在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。</p>\n<h2 id=\"什么是滚动锚定\"><a href=\"#什么是滚动锚定\" class=\"headerlink\" title=\"什么是滚动锚定\"></a>什么是滚动锚定</h2><p>滚动锚定是一种浏览器功能，它是用来防止你在 DOM 完全加载之前向下滚动网页的常见情况，如果没有滚动锚定，你所看到的内容就会一直被往下推。大家可能有过这样的浏览体验，就是图片很多的时候，例如漫画网站，在手机端，垂直布局这种，如果上方的图片加载慢，那么下方的图片看着看着就会被推下来，然后自己又要重新去滚动定位。</p>\n<p>这是一个不太友好的浏览器体验行为。 于是，Chrome 56（2017年）和Firefox 66（2019年）开始，这些浏览器就对滚动行为进行了优化，实现了一种“滚动锚定”的交互行为。 具体描述为：当前视区上面的内容突然出现的时候，浏览器自动改变滚动高度，让视区窗口区域内容固定，就像滚动效果被锚定一样。</p>\n<p>因此，在PC端，在Chrome浏览器下和Firefox浏览器下，当你浏览网页的时候，是感觉不到页面跳动的，就是滚动锚定在其作用。</p>\n<h2 id=\"overflow-anchor属性\"><a href=\"#overflow-anchor属性\" class=\"headerlink\" title=\"overflow-anchor属性\"></a>overflow-anchor属性</h2><p>overflow-anchor属性的值非常简单，它接受两个值，它们本质上切换是否启用该功能。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">overflow-anchor: [ <span class=\"hljs-keyword\">auto</span> | none ];<br></code></pre></td></tr></table></figure>\n\n<p>auto（默认）：在页面或元素应用它的部分启用滚动锚定。</p>\n<p>none：禁用部分或全部网页的滚动锚定，或将 DOM 的一部分排除在锚定之外，从而允许内容重排。</p>\n<p>overflow-anchor属性可以放在body中对全局生效，也可以单独放在某个元素中，对部分页面元素起作用。</p>\n<h2 id=\"应用案例\"><a href=\"#应用案例\" class=\"headerlink\" title=\"应用案例\"></a>应用案例</h2><p>下面我们看看具体应用到元素中会有什么不同，下面的案例是实时效果，大家可以直接滚动操作，左边是默认的overflow-anchor:auto，右边设置的是overflow-anchor:none。</p>\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/oWgENp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"overflow-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/oWgENp\"> overflow-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n<p>这个属性其实对于很多用户刷新应用都非常有用。 例如，一个聊天应用程序，在这个页面中，新消息会添加到底部的 DOM，如果你希望一直看到最新的消息，这个时候就可以把overflow-anchor设置为none，详细参考下面的demo：</p>\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/bGbeBdp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"&quot;Stay at the bottom&quot; scrolling with scroll-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/bGbeBdp\"> &amp;quot;Stay at the bottom&amp;quot; scrolling with scroll-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虽然overflow-anchor属性还不是W3C的标准，但是已经提上了日程，提供了规范的草案报告可供阅读，并且自版本 56 起已被 Chrome 采用。Mozilla 正在考虑在 Firefox 中使用类似的功能。 随着越来越多的浏览器采用滚动锚定功能，我们可能期望看到更多浏览器支持溢出锚定，因为它提供了明确的控制来选择是否使用滚动锚定这个特性。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230706404-76369b04-886e-4482-94f1-f8df6bdb54dd.png\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"CSS-overflow-anchor属性的一些坑\"><a href=\"#CSS-overflow-anchor属性的一些坑\" class=\"headerlink\" title=\"CSS overflow-anchor属性的一些坑\"></a>CSS overflow-anchor属性的一些坑</h1><p>之前在做虚拟滚动组件，但是在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。</p>\n<p>大家都知道，比较常用的虚拟滚动就是只显示中间用户能够看的见的值，其余用户看不见的值，就填充空白的div以优化性能。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230706172-d81bb2ca-06d4-4a57-9c1a-7e97d5ae36c8.png\" alt=\"image\"></p>\n<p>但是这次在做虚拟滚动的时候却发现当你往上方填充空白区间的时候，scrollTop属性也跟着更新了，导致了计算时候的一些错误。后来发现是CSS overflow-anchor属性导致的问题。下面我来讲讲这个滚动锚定属性是有什么作用的。</p>\n<h2 id=\"什么是滚动锚定\"><a href=\"#什么是滚动锚定\" class=\"headerlink\" title=\"什么是滚动锚定\"></a>什么是滚动锚定</h2><p>滚动锚定是一种浏览器功能，它是用来防止你在 DOM 完全加载之前向下滚动网页的常见情况，如果没有滚动锚定，你所看到的内容就会一直被往下推。大家可能有过这样的浏览体验，就是图片很多的时候，例如漫画网站，在手机端，垂直布局这种，如果上方的图片加载慢，那么下方的图片看着看着就会被推下来，然后自己又要重新去滚动定位。</p>\n<p>这是一个不太友好的浏览器体验行为。 于是，Chrome 56（2017年）和Firefox 66（2019年）开始，这些浏览器就对滚动行为进行了优化，实现了一种“滚动锚定”的交互行为。 具体描述为：当前视区上面的内容突然出现的时候，浏览器自动改变滚动高度，让视区窗口区域内容固定，就像滚动效果被锚定一样。</p>\n<p>因此，在PC端，在Chrome浏览器下和Firefox浏览器下，当你浏览网页的时候，是感觉不到页面跳动的，就是滚动锚定在其作用。</p>\n<h2 id=\"overflow-anchor属性\"><a href=\"#overflow-anchor属性\" class=\"headerlink\" title=\"overflow-anchor属性\"></a>overflow-anchor属性</h2><p>overflow-anchor属性的值非常简单，它接受两个值，它们本质上切换是否启用该功能。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">overflow-anchor: [ <span class=\"hljs-keyword\">auto</span> | none ];<br></code></pre></td></tr></table></figure>\n\n<p>auto（默认）：在页面或元素应用它的部分启用滚动锚定。</p>\n<p>none：禁用部分或全部网页的滚动锚定，或将 DOM 的一部分排除在锚定之外，从而允许内容重排。</p>\n<p>overflow-anchor属性可以放在body中对全局生效，也可以单独放在某个元素中，对部分页面元素起作用。</p>\n<h2 id=\"应用案例\"><a href=\"#应用案例\" class=\"headerlink\" title=\"应用案例\"></a>应用案例</h2><p>下面我们看看具体应用到元素中会有什么不同，下面的案例是实时效果，大家可以直接滚动操作，左边是默认的overflow-anchor:auto，右边设置的是overflow-anchor:none。</p>\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/oWgENp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"overflow-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/oWgENp\"> overflow-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n<p>这个属性其实对于很多用户刷新应用都非常有用。 例如，一个聊天应用程序，在这个页面中，新消息会添加到底部的 DOM，如果你希望一直看到最新的消息，这个时候就可以把overflow-anchor设置为none，详细参考下面的demo：</p>\n<iframe allowfullscreen=\"true\" frameborder=\"no\" scrolling=\"no\" src=\"https://codepen.io/chriscoyier/embed/bGbeBdp?default-tab=result\" style=\"height: 400px; width: 100%;\" title=\"&quot;Stay at the bottom&quot; scrolling with scroll-anchor\">See the Pen <a href=\"https://codepen.io/chriscoyier/pen/bGbeBdp\"> &amp;quot;Stay at the bottom&amp;quot; scrolling with scroll-anchor</a> by Chris Coyier (<a href=\"https://codepen.io/chriscoyier\">@chriscoyier</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>虽然overflow-anchor属性还不是W3C的标准，但是已经提上了日程，提供了规范的草案报告可供阅读，并且自版本 56 起已被 Chrome 采用。Mozilla 正在考虑在 Firefox 中使用类似的功能。 随着越来越多的浏览器采用滚动锚定功能，我们可能期望看到更多浏览器支持溢出锚定，因为它提供了明确的控制来选择是否使用滚动锚定这个特性。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230706404-76369b04-886e-4482-94f1-f8df6bdb54dd.png\" alt=\"image\"></p>\n"},{"title":"前端日志上报的实现","date":"2023-04-13T09:48:07.000Z","_content":"\n# 前端日志上报的实现\n\n在前端开发中，日志上报是一个常见的需求，它涵盖了从按钮点击到整个操作流程追踪的范围。为了达到这个目的，需要进行日志记录、埋点和日志上报等工作。\n\n## 为什么我们需要前端日志\n\n因为绝大多数用户都是通过前端来与系统进行交互的，前端的质量和稳定性就成了用户对于系统最直观的体现。同时前端代码又是直接运行在用户的电脑上的，很多情况下出现了错误或者页面崩溃的情况，开发人员都没有办法第一时间发现和进行处理。同时由于用户的系统和浏览器显示设备等多样性，使得很多情况未必能在开发时候就考虑周到。\n\n综上所述，前端日志就显得格外重要。它能够及时反馈用户的错误，包括用户的浏览器，操作系统，显示分辨率等参数，以便后期复现以及修复问题。\n\n## 日志内容\n\n为了收集准确且有用的信息，以便用于故障排除和调试，前端日志应包括以下内容：\n\n时间戳：错误发生的时间。\n\n错误消息：关于所发生错误的简明描述。\n\n错误类型：错误的类型，例如语法错误、运行时错误或逻辑错误。\n\n严重程度：错误对系统或用户体验造成的影响级别。\n\n用户信息：关于遇到错误的用户的详细信息，例如他们的浏览器、设备、操作系统和 IP 地址。\n\n堆栈跟踪：导致错误的代码和函数的列表。\n\n上下文信息：其他信息，可以帮助开发人员了解发生错误的情况，例如应用程序的当前状态、用户的操作以及任何以前的错误或事件。\n\n```ts\nexport interface AppInfo {\n    appID?: string\n    version?: string\n    appName?: string\n    [key: string]: any\n}\n\nexport interface SystemInfo {\n    ua?: string\n    isCookie?: number\n    cookie?: string\n    screenHeight?: number | string\n    screenWidth?: number | string\n    [key: string]: any\n}\n\nexport interface UserInfo {\n    userID?: string\n    userLanguage?: string\n    token?: string\n    [key: string]: any\n}\n\nexport interface EasyEvent {\n    eventType: string\n    logLevel?: LOG_LEVEL\n    elemId?: string\n    createTime?: string\n    extraParams?: object\n}\n```\n\n## 日志上报的实现\n\n我们可以相信的到，日志上报最方便的就是做成一个console类似的类，把错误信息直接传入方法中即可\n```javascript\neasyLogReport.log({\n    eventType: 'onLoad',\n    elemId: 'App',\n    extraParams: {\n        // other extra params\n        type: 'onLoad'\n    }\n})\n```\neventType - 埋点事件类型，它可能是点击事件、页面初始化、页面激活、请求事件...\n\nelemId - 埋点标识，后续进行埋点数据提取的重要标识\n\nextraParams - 额外的上报内容，丰富埋点的含义帮助后续做更加精细、完善的分析\n\n获取到了这些日志之后，我们可以在前端过滤一下这个日志，因为某些错误有可能在短时间内触发了很多次。我们就只需要把这些相同内容的日志聚合一下，没必要100个相同的报错一起给后端发去，减少网络流量以及后端处理压力。\n实践中选择了后端进行处理，主要担心前端性能问题，而且队列也不能设置太大，其实对于重复生成的错误日志也不能很好地过滤。\n\n```javascript\n// 过滤1秒内连续抛出同一错误\ndebounce = ()=>{  \ntry {\n  if(this.timeout !== null){\n    clearTimeout(this.timeout);\n  }      \n  this.timeout = setTimeout(()=>{\n    const max = this.props.max || 1;\n    if (this.queue && this.queue.size >= max) {\n      this.catchBack()\n    }\n  }, 1000);    \n} catch (error) {\n  console.log(this.selfError + \"debounce\",error)\n}\n}\n```\n\n之后就是给服务器发送日志了。这里并没有所谓最正确的做法，因为最终发送日志上报请求的方式有很多种，有些是GET请求、有些是请求一张图片而有些则是发送POST请求。不同的请求方式，发送日志内容的时机也不太一样。\n\n如果是GET请求的方式进行日志上报，则一般是埋点触发后，产生日志条目就直接发送到日志服务。\n\n如果是POST请求的方式，则有大多数会在项目中维护一个日志上报队列，从日志条数、上报间隔等维度进行日志条目的统一上报。\n\n无论是使用哪种方式进行日志上报，都需要在上报前对对埋点的内容进行预处理，让它符合日志服务的要求。\n\n```javascript\n/* report log by img url function */\nexport const sendImage = (data: ReportContent, sendUrl: string)=>{\n    let image = new Image();\n    image.src = sendUrl + \"/\" + encodeURIComponent(JSON.stringify(data));\n    image.onerror = () => {\n        console.error('EasyLogReport - log data send from image src error')\n    }\n}\n\n/* report log by sendBeacon function */\nexport const beacon = (data: ReportContent, sendUrl: string)=>{\n    if (!navigator?.sendBeacon) {\n        console.error('EasyLogReport - current env don\\'t support sendBeacon!')\n        return\n    }\n    navigator.sendBeacon(sendUrl, encodeURIComponent(JSON.stringify(data)))\n}\n```\n\n上面的代码分别是通过图片get的方法进行返回，以及使用因为Beacon的方式进行返回。\n\n这里建议使用因为Beacon的方式，因为Beacon API 是用来向 server 端传输小批量数据的，并且不需要等待 server 端的响应。相比与xhr的请求，Beacon的优点不接受响应，浏览器可以把请求队列起来，然后发送，而不会阻塞任何其他代码的执行。\n\n比如说你需要记录 unload 或 beforeunload 的事件日志记录。这些事件通常在用户跳转链接时触发。这里的问题是，unload 事件中的代码可以阻塞代码执行且推迟页面的卸载。如果当前页面的卸载被推迟了，那也就是说，下个页面的加载也被推迟了，最后导致页面跳转的体验变得迟缓。\n\n最后用一张图来总结一下整个日志上报的实践过程。\n\n![5c6f01d93d1d4de1bf8eb2d49e714e59~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0](https://user-images.githubusercontent.com/2912039/230709216-1b491c6c-3704-4103-ba06-b057f33422b8.jpg)\n\n最后，插件地址在 <https://www.npmjs.com/package/easy-log-report>，这个只是日志上报插件，后续会进行错误捕捉，性能监控插件的开发。\n\n参考资料：\n\n[前端错误日志收集方案](https://zhuanlan.zhihu.com/p/47749670)\n\n[前端日志上报实践](https://juejin.cn/post/7107539513378865188)\n\n[手撸一个前端日志上报组件](https://www.cnblogs.com/Khadron/p/14535334.html)\n\n[react-error-catch](https://github.com/xian107/react-error-catch)","source":"_posts/杂谈/前端日志上报的实现.md","raw":"---\ntitle: 前端日志上报的实现\ntags:\n  - javascript\n  - npm\n  - 日志\ncategories:\n  - 杂谈\ndate: 2023-04-13 17:48:07\n---\n\n# 前端日志上报的实现\n\n在前端开发中，日志上报是一个常见的需求，它涵盖了从按钮点击到整个操作流程追踪的范围。为了达到这个目的，需要进行日志记录、埋点和日志上报等工作。\n\n## 为什么我们需要前端日志\n\n因为绝大多数用户都是通过前端来与系统进行交互的，前端的质量和稳定性就成了用户对于系统最直观的体现。同时前端代码又是直接运行在用户的电脑上的，很多情况下出现了错误或者页面崩溃的情况，开发人员都没有办法第一时间发现和进行处理。同时由于用户的系统和浏览器显示设备等多样性，使得很多情况未必能在开发时候就考虑周到。\n\n综上所述，前端日志就显得格外重要。它能够及时反馈用户的错误，包括用户的浏览器，操作系统，显示分辨率等参数，以便后期复现以及修复问题。\n\n## 日志内容\n\n为了收集准确且有用的信息，以便用于故障排除和调试，前端日志应包括以下内容：\n\n时间戳：错误发生的时间。\n\n错误消息：关于所发生错误的简明描述。\n\n错误类型：错误的类型，例如语法错误、运行时错误或逻辑错误。\n\n严重程度：错误对系统或用户体验造成的影响级别。\n\n用户信息：关于遇到错误的用户的详细信息，例如他们的浏览器、设备、操作系统和 IP 地址。\n\n堆栈跟踪：导致错误的代码和函数的列表。\n\n上下文信息：其他信息，可以帮助开发人员了解发生错误的情况，例如应用程序的当前状态、用户的操作以及任何以前的错误或事件。\n\n```ts\nexport interface AppInfo {\n    appID?: string\n    version?: string\n    appName?: string\n    [key: string]: any\n}\n\nexport interface SystemInfo {\n    ua?: string\n    isCookie?: number\n    cookie?: string\n    screenHeight?: number | string\n    screenWidth?: number | string\n    [key: string]: any\n}\n\nexport interface UserInfo {\n    userID?: string\n    userLanguage?: string\n    token?: string\n    [key: string]: any\n}\n\nexport interface EasyEvent {\n    eventType: string\n    logLevel?: LOG_LEVEL\n    elemId?: string\n    createTime?: string\n    extraParams?: object\n}\n```\n\n## 日志上报的实现\n\n我们可以相信的到，日志上报最方便的就是做成一个console类似的类，把错误信息直接传入方法中即可\n```javascript\neasyLogReport.log({\n    eventType: 'onLoad',\n    elemId: 'App',\n    extraParams: {\n        // other extra params\n        type: 'onLoad'\n    }\n})\n```\neventType - 埋点事件类型，它可能是点击事件、页面初始化、页面激活、请求事件...\n\nelemId - 埋点标识，后续进行埋点数据提取的重要标识\n\nextraParams - 额外的上报内容，丰富埋点的含义帮助后续做更加精细、完善的分析\n\n获取到了这些日志之后，我们可以在前端过滤一下这个日志，因为某些错误有可能在短时间内触发了很多次。我们就只需要把这些相同内容的日志聚合一下，没必要100个相同的报错一起给后端发去，减少网络流量以及后端处理压力。\n实践中选择了后端进行处理，主要担心前端性能问题，而且队列也不能设置太大，其实对于重复生成的错误日志也不能很好地过滤。\n\n```javascript\n// 过滤1秒内连续抛出同一错误\ndebounce = ()=>{  \ntry {\n  if(this.timeout !== null){\n    clearTimeout(this.timeout);\n  }      \n  this.timeout = setTimeout(()=>{\n    const max = this.props.max || 1;\n    if (this.queue && this.queue.size >= max) {\n      this.catchBack()\n    }\n  }, 1000);    \n} catch (error) {\n  console.log(this.selfError + \"debounce\",error)\n}\n}\n```\n\n之后就是给服务器发送日志了。这里并没有所谓最正确的做法，因为最终发送日志上报请求的方式有很多种，有些是GET请求、有些是请求一张图片而有些则是发送POST请求。不同的请求方式，发送日志内容的时机也不太一样。\n\n如果是GET请求的方式进行日志上报，则一般是埋点触发后，产生日志条目就直接发送到日志服务。\n\n如果是POST请求的方式，则有大多数会在项目中维护一个日志上报队列，从日志条数、上报间隔等维度进行日志条目的统一上报。\n\n无论是使用哪种方式进行日志上报，都需要在上报前对对埋点的内容进行预处理，让它符合日志服务的要求。\n\n```javascript\n/* report log by img url function */\nexport const sendImage = (data: ReportContent, sendUrl: string)=>{\n    let image = new Image();\n    image.src = sendUrl + \"/\" + encodeURIComponent(JSON.stringify(data));\n    image.onerror = () => {\n        console.error('EasyLogReport - log data send from image src error')\n    }\n}\n\n/* report log by sendBeacon function */\nexport const beacon = (data: ReportContent, sendUrl: string)=>{\n    if (!navigator?.sendBeacon) {\n        console.error('EasyLogReport - current env don\\'t support sendBeacon!')\n        return\n    }\n    navigator.sendBeacon(sendUrl, encodeURIComponent(JSON.stringify(data)))\n}\n```\n\n上面的代码分别是通过图片get的方法进行返回，以及使用因为Beacon的方式进行返回。\n\n这里建议使用因为Beacon的方式，因为Beacon API 是用来向 server 端传输小批量数据的，并且不需要等待 server 端的响应。相比与xhr的请求，Beacon的优点不接受响应，浏览器可以把请求队列起来，然后发送，而不会阻塞任何其他代码的执行。\n\n比如说你需要记录 unload 或 beforeunload 的事件日志记录。这些事件通常在用户跳转链接时触发。这里的问题是，unload 事件中的代码可以阻塞代码执行且推迟页面的卸载。如果当前页面的卸载被推迟了，那也就是说，下个页面的加载也被推迟了，最后导致页面跳转的体验变得迟缓。\n\n最后用一张图来总结一下整个日志上报的实践过程。\n\n![5c6f01d93d1d4de1bf8eb2d49e714e59~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0](https://user-images.githubusercontent.com/2912039/230709216-1b491c6c-3704-4103-ba06-b057f33422b8.jpg)\n\n最后，插件地址在 <https://www.npmjs.com/package/easy-log-report>，这个只是日志上报插件，后续会进行错误捕捉，性能监控插件的开发。\n\n参考资料：\n\n[前端错误日志收集方案](https://zhuanlan.zhihu.com/p/47749670)\n\n[前端日志上报实践](https://juejin.cn/post/7107539513378865188)\n\n[手撸一个前端日志上报组件](https://www.cnblogs.com/Khadron/p/14535334.html)\n\n[react-error-catch](https://github.com/xian107/react-error-catch)","slug":"杂谈/前端日志上报的实现","published":1,"updated":"2023-04-13T09:54:44.498Z","_id":"clgey1juy000ffpc3as1lfy3r","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前端日志上报的实现\"><a href=\"#前端日志上报的实现\" class=\"headerlink\" title=\"前端日志上报的实现\"></a>前端日志上报的实现</h1><p>在前端开发中，日志上报是一个常见的需求，它涵盖了从按钮点击到整个操作流程追踪的范围。为了达到这个目的，需要进行日志记录、埋点和日志上报等工作。</p>\n<h2 id=\"为什么我们需要前端日志\"><a href=\"#为什么我们需要前端日志\" class=\"headerlink\" title=\"为什么我们需要前端日志\"></a>为什么我们需要前端日志</h2><p>因为绝大多数用户都是通过前端来与系统进行交互的，前端的质量和稳定性就成了用户对于系统最直观的体现。同时前端代码又是直接运行在用户的电脑上的，很多情况下出现了错误或者页面崩溃的情况，开发人员都没有办法第一时间发现和进行处理。同时由于用户的系统和浏览器显示设备等多样性，使得很多情况未必能在开发时候就考虑周到。</p>\n<p>综上所述，前端日志就显得格外重要。它能够及时反馈用户的错误，包括用户的浏览器，操作系统，显示分辨率等参数，以便后期复现以及修复问题。</p>\n<h2 id=\"日志内容\"><a href=\"#日志内容\" class=\"headerlink\" title=\"日志内容\"></a>日志内容</h2><p>为了收集准确且有用的信息，以便用于故障排除和调试，前端日志应包括以下内容：</p>\n<p>时间戳：错误发生的时间。</p>\n<p>错误消息：关于所发生错误的简明描述。</p>\n<p>错误类型：错误的类型，例如语法错误、运行时错误或逻辑错误。</p>\n<p>严重程度：错误对系统或用户体验造成的影响级别。</p>\n<p>用户信息：关于遇到错误的用户的详细信息，例如他们的浏览器、设备、操作系统和 IP 地址。</p>\n<p>堆栈跟踪：导致错误的代码和函数的列表。</p>\n<p>上下文信息：其他信息，可以帮助开发人员了解发生错误的情况，例如应用程序的当前状态、用户的操作以及任何以前的错误或事件。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">AppInfo</span> &#123;<br>    appID?: <span class=\"hljs-built_in\">string</span><br>    version?: <span class=\"hljs-built_in\">string</span><br>    appName?: <span class=\"hljs-built_in\">string</span><br>    [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SystemInfo</span> &#123;<br>    ua?: <span class=\"hljs-built_in\">string</span><br>    isCookie?: <span class=\"hljs-built_in\">number</span><br>    cookie?: <span class=\"hljs-built_in\">string</span><br>    screenHeight?: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span><br>    screenWidth?: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span><br>    [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UserInfo</span> &#123;<br>    userID?: <span class=\"hljs-built_in\">string</span><br>    userLanguage?: <span class=\"hljs-built_in\">string</span><br>    token?: <span class=\"hljs-built_in\">string</span><br>    [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">EasyEvent</span> &#123;<br>    <span class=\"hljs-attr\">eventType</span>: <span class=\"hljs-built_in\">string</span><br>    logLevel?: <span class=\"hljs-variable constant_\">LOG_LEVEL</span><br>    elemId?: <span class=\"hljs-built_in\">string</span><br>    createTime?: <span class=\"hljs-built_in\">string</span><br>    extraParams?: <span class=\"hljs-built_in\">object</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"日志上报的实现\"><a href=\"#日志上报的实现\" class=\"headerlink\" title=\"日志上报的实现\"></a>日志上报的实现</h2><p>我们可以相信的到，日志上报最方便的就是做成一个console类似的类，把错误信息直接传入方法中即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">easyLogReport.<span class=\"hljs-title function_\">log</span>(&#123;<br>    <span class=\"hljs-attr\">eventType</span>: <span class=\"hljs-string\">&#x27;onLoad&#x27;</span>,<br>    <span class=\"hljs-attr\">elemId</span>: <span class=\"hljs-string\">&#x27;App&#x27;</span>,<br>    <span class=\"hljs-attr\">extraParams</span>: &#123;<br>        <span class=\"hljs-comment\">// other extra params</span><br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;onLoad&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>eventType - 埋点事件类型，它可能是点击事件、页面初始化、页面激活、请求事件…</p>\n<p>elemId - 埋点标识，后续进行埋点数据提取的重要标识</p>\n<p>extraParams - 额外的上报内容，丰富埋点的含义帮助后续做更加精细、完善的分析</p>\n<p>获取到了这些日志之后，我们可以在前端过滤一下这个日志，因为某些错误有可能在短时间内触发了很多次。我们就只需要把这些相同内容的日志聚合一下，没必要100个相同的报错一起给后端发去，减少网络流量以及后端处理压力。<br>实践中选择了后端进行处理，主要担心前端性能问题，而且队列也不能设置太大，其实对于重复生成的错误日志也不能很好地过滤。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 过滤1秒内连续抛出同一错误</span><br>debounce = <span class=\"hljs-function\">()=&gt;</span>&#123;  <br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeout</span> !== <span class=\"hljs-literal\">null</span>)&#123;<br>    <span class=\"hljs-built_in\">clearTimeout</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeout</span>);<br>  &#125;      <br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeout</span> = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> max = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">max</span> || <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queue</span> &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queue</span>.<span class=\"hljs-property\">size</span> &gt;= max) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">catchBack</span>()<br>    &#125;<br>  &#125;, <span class=\"hljs-number\">1000</span>);    <br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">selfError</span> + <span class=\"hljs-string\">&quot;debounce&quot;</span>,error)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>之后就是给服务器发送日志了。这里并没有所谓最正确的做法，因为最终发送日志上报请求的方式有很多种，有些是GET请求、有些是请求一张图片而有些则是发送POST请求。不同的请求方式，发送日志内容的时机也不太一样。</p>\n<p>如果是GET请求的方式进行日志上报，则一般是埋点触发后，产生日志条目就直接发送到日志服务。</p>\n<p>如果是POST请求的方式，则有大多数会在项目中维护一个日志上报队列，从日志条数、上报间隔等维度进行日志条目的统一上报。</p>\n<p>无论是使用哪种方式进行日志上报，都需要在上报前对对埋点的内容进行预处理，让它符合日志服务的要求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* report log by img url function */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sendImage</span> = (<span class=\"hljs-params\">data: ReportContent, sendUrl: string</span>)=&gt;&#123;<br>    <span class=\"hljs-keyword\">let</span> image = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Image</span>();<br>    image.<span class=\"hljs-property\">src</span> = sendUrl + <span class=\"hljs-string\">&quot;/&quot;</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data));<br>    image.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;EasyLogReport - log data send from image src error&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* report log by sendBeacon function */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">beacon</span> = (<span class=\"hljs-params\">data: ReportContent, sendUrl: string</span>)=&gt;&#123;<br>    <span class=\"hljs-keyword\">if</span> (!navigator?.<span class=\"hljs-property\">sendBeacon</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;EasyLogReport - current env don\\&#x27;t support sendBeacon!&#x27;</span>)<br>        <span class=\"hljs-keyword\">return</span><br>    &#125;<br>    navigator.<span class=\"hljs-title function_\">sendBeacon</span>(sendUrl, <span class=\"hljs-built_in\">encodeURIComponent</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data)))<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码分别是通过图片get的方法进行返回，以及使用因为Beacon的方式进行返回。</p>\n<p>这里建议使用因为Beacon的方式，因为Beacon API 是用来向 server 端传输小批量数据的，并且不需要等待 server 端的响应。相比与xhr的请求，Beacon的优点不接受响应，浏览器可以把请求队列起来，然后发送，而不会阻塞任何其他代码的执行。</p>\n<p>比如说你需要记录 unload 或 beforeunload 的事件日志记录。这些事件通常在用户跳转链接时触发。这里的问题是，unload 事件中的代码可以阻塞代码执行且推迟页面的卸载。如果当前页面的卸载被推迟了，那也就是说，下个页面的加载也被推迟了，最后导致页面跳转的体验变得迟缓。</p>\n<p>最后用一张图来总结一下整个日志上报的实践过程。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230709216-1b491c6c-3704-4103-ba06-b057f33422b8.jpg\" alt=\"5c6f01d93d1d4de1bf8eb2d49e714e59~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0\"></p>\n<p>最后，插件地址在 <a href=\"https://www.npmjs.com/package/easy-log-report\">https://www.npmjs.com/package/easy-log-report</a>，这个只是日志上报插件，后续会进行错误捕捉，性能监控插件的开发。</p>\n<p>参考资料：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/47749670\">前端错误日志收集方案</a></p>\n<p><a href=\"https://juejin.cn/post/7107539513378865188\">前端日志上报实践</a></p>\n<p><a href=\"https://www.cnblogs.com/Khadron/p/14535334.html\">手撸一个前端日志上报组件</a></p>\n<p><a href=\"https://github.com/xian107/react-error-catch\">react-error-catch</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端日志上报的实现\"><a href=\"#前端日志上报的实现\" class=\"headerlink\" title=\"前端日志上报的实现\"></a>前端日志上报的实现</h1><p>在前端开发中，日志上报是一个常见的需求，它涵盖了从按钮点击到整个操作流程追踪的范围。为了达到这个目的，需要进行日志记录、埋点和日志上报等工作。</p>\n<h2 id=\"为什么我们需要前端日志\"><a href=\"#为什么我们需要前端日志\" class=\"headerlink\" title=\"为什么我们需要前端日志\"></a>为什么我们需要前端日志</h2><p>因为绝大多数用户都是通过前端来与系统进行交互的，前端的质量和稳定性就成了用户对于系统最直观的体现。同时前端代码又是直接运行在用户的电脑上的，很多情况下出现了错误或者页面崩溃的情况，开发人员都没有办法第一时间发现和进行处理。同时由于用户的系统和浏览器显示设备等多样性，使得很多情况未必能在开发时候就考虑周到。</p>\n<p>综上所述，前端日志就显得格外重要。它能够及时反馈用户的错误，包括用户的浏览器，操作系统，显示分辨率等参数，以便后期复现以及修复问题。</p>\n<h2 id=\"日志内容\"><a href=\"#日志内容\" class=\"headerlink\" title=\"日志内容\"></a>日志内容</h2><p>为了收集准确且有用的信息，以便用于故障排除和调试，前端日志应包括以下内容：</p>\n<p>时间戳：错误发生的时间。</p>\n<p>错误消息：关于所发生错误的简明描述。</p>\n<p>错误类型：错误的类型，例如语法错误、运行时错误或逻辑错误。</p>\n<p>严重程度：错误对系统或用户体验造成的影响级别。</p>\n<p>用户信息：关于遇到错误的用户的详细信息，例如他们的浏览器、设备、操作系统和 IP 地址。</p>\n<p>堆栈跟踪：导致错误的代码和函数的列表。</p>\n<p>上下文信息：其他信息，可以帮助开发人员了解发生错误的情况，例如应用程序的当前状态、用户的操作以及任何以前的错误或事件。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">AppInfo</span> &#123;<br>    appID?: <span class=\"hljs-built_in\">string</span><br>    version?: <span class=\"hljs-built_in\">string</span><br>    appName?: <span class=\"hljs-built_in\">string</span><br>    [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">SystemInfo</span> &#123;<br>    ua?: <span class=\"hljs-built_in\">string</span><br>    isCookie?: <span class=\"hljs-built_in\">number</span><br>    cookie?: <span class=\"hljs-built_in\">string</span><br>    screenHeight?: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span><br>    screenWidth?: <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span><br>    [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">UserInfo</span> &#123;<br>    userID?: <span class=\"hljs-built_in\">string</span><br>    userLanguage?: <span class=\"hljs-built_in\">string</span><br>    token?: <span class=\"hljs-built_in\">string</span><br>    [<span class=\"hljs-attr\">key</span>: <span class=\"hljs-built_in\">string</span>]: <span class=\"hljs-built_in\">any</span><br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">EasyEvent</span> &#123;<br>    <span class=\"hljs-attr\">eventType</span>: <span class=\"hljs-built_in\">string</span><br>    logLevel?: <span class=\"hljs-variable constant_\">LOG_LEVEL</span><br>    elemId?: <span class=\"hljs-built_in\">string</span><br>    createTime?: <span class=\"hljs-built_in\">string</span><br>    extraParams?: <span class=\"hljs-built_in\">object</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"日志上报的实现\"><a href=\"#日志上报的实现\" class=\"headerlink\" title=\"日志上报的实现\"></a>日志上报的实现</h2><p>我们可以相信的到，日志上报最方便的就是做成一个console类似的类，把错误信息直接传入方法中即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">easyLogReport.<span class=\"hljs-title function_\">log</span>(&#123;<br>    <span class=\"hljs-attr\">eventType</span>: <span class=\"hljs-string\">&#x27;onLoad&#x27;</span>,<br>    <span class=\"hljs-attr\">elemId</span>: <span class=\"hljs-string\">&#x27;App&#x27;</span>,<br>    <span class=\"hljs-attr\">extraParams</span>: &#123;<br>        <span class=\"hljs-comment\">// other extra params</span><br>        <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;onLoad&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<p>eventType - 埋点事件类型，它可能是点击事件、页面初始化、页面激活、请求事件…</p>\n<p>elemId - 埋点标识，后续进行埋点数据提取的重要标识</p>\n<p>extraParams - 额外的上报内容，丰富埋点的含义帮助后续做更加精细、完善的分析</p>\n<p>获取到了这些日志之后，我们可以在前端过滤一下这个日志，因为某些错误有可能在短时间内触发了很多次。我们就只需要把这些相同内容的日志聚合一下，没必要100个相同的报错一起给后端发去，减少网络流量以及后端处理压力。<br>实践中选择了后端进行处理，主要担心前端性能问题，而且队列也不能设置太大，其实对于重复生成的错误日志也不能很好地过滤。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 过滤1秒内连续抛出同一错误</span><br>debounce = <span class=\"hljs-function\">()=&gt;</span>&#123;  <br><span class=\"hljs-keyword\">try</span> &#123;<br>  <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeout</span> !== <span class=\"hljs-literal\">null</span>)&#123;<br>    <span class=\"hljs-built_in\">clearTimeout</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeout</span>);<br>  &#125;      <br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">timeout</span> = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">()=&gt;</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> max = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">props</span>.<span class=\"hljs-property\">max</span> || <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queue</span> &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">queue</span>.<span class=\"hljs-property\">size</span> &gt;= max) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">catchBack</span>()<br>    &#125;<br>  &#125;, <span class=\"hljs-number\">1000</span>);    <br>&#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">selfError</span> + <span class=\"hljs-string\">&quot;debounce&quot;</span>,error)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>之后就是给服务器发送日志了。这里并没有所谓最正确的做法，因为最终发送日志上报请求的方式有很多种，有些是GET请求、有些是请求一张图片而有些则是发送POST请求。不同的请求方式，发送日志内容的时机也不太一样。</p>\n<p>如果是GET请求的方式进行日志上报，则一般是埋点触发后，产生日志条目就直接发送到日志服务。</p>\n<p>如果是POST请求的方式，则有大多数会在项目中维护一个日志上报队列，从日志条数、上报间隔等维度进行日志条目的统一上报。</p>\n<p>无论是使用哪种方式进行日志上报，都需要在上报前对对埋点的内容进行预处理，让它符合日志服务的要求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">/* report log by img url function */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">sendImage</span> = (<span class=\"hljs-params\">data: ReportContent, sendUrl: string</span>)=&gt;&#123;<br>    <span class=\"hljs-keyword\">let</span> image = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Image</span>();<br>    image.<span class=\"hljs-property\">src</span> = sendUrl + <span class=\"hljs-string\">&quot;/&quot;</span> + <span class=\"hljs-built_in\">encodeURIComponent</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data));<br>    image.<span class=\"hljs-property\">onerror</span> = <span class=\"hljs-function\">() =&gt;</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;EasyLogReport - log data send from image src error&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">/* report log by sendBeacon function */</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">beacon</span> = (<span class=\"hljs-params\">data: ReportContent, sendUrl: string</span>)=&gt;&#123;<br>    <span class=\"hljs-keyword\">if</span> (!navigator?.<span class=\"hljs-property\">sendBeacon</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&#x27;EasyLogReport - current env don\\&#x27;t support sendBeacon!&#x27;</span>)<br>        <span class=\"hljs-keyword\">return</span><br>    &#125;<br>    navigator.<span class=\"hljs-title function_\">sendBeacon</span>(sendUrl, <span class=\"hljs-built_in\">encodeURIComponent</span>(<span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(data)))<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的代码分别是通过图片get的方法进行返回，以及使用因为Beacon的方式进行返回。</p>\n<p>这里建议使用因为Beacon的方式，因为Beacon API 是用来向 server 端传输小批量数据的，并且不需要等待 server 端的响应。相比与xhr的请求，Beacon的优点不接受响应，浏览器可以把请求队列起来，然后发送，而不会阻塞任何其他代码的执行。</p>\n<p>比如说你需要记录 unload 或 beforeunload 的事件日志记录。这些事件通常在用户跳转链接时触发。这里的问题是，unload 事件中的代码可以阻塞代码执行且推迟页面的卸载。如果当前页面的卸载被推迟了，那也就是说，下个页面的加载也被推迟了，最后导致页面跳转的体验变得迟缓。</p>\n<p>最后用一张图来总结一下整个日志上报的实践过程。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230709216-1b491c6c-3704-4103-ba06-b057f33422b8.jpg\" alt=\"5c6f01d93d1d4de1bf8eb2d49e714e59~tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0\"></p>\n<p>最后，插件地址在 <a href=\"https://www.npmjs.com/package/easy-log-report\">https://www.npmjs.com/package/easy-log-report</a>，这个只是日志上报插件，后续会进行错误捕捉，性能监控插件的开发。</p>\n<p>参考资料：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/47749670\">前端错误日志收集方案</a></p>\n<p><a href=\"https://juejin.cn/post/7107539513378865188\">前端日志上报实践</a></p>\n<p><a href=\"https://www.cnblogs.com/Khadron/p/14535334.html\">手撸一个前端日志上报组件</a></p>\n<p><a href=\"https://github.com/xian107/react-error-catch\">react-error-catch</a></p>\n"},{"title":"前端对接GPT实现打字机效果","date":"2023-04-13T09:46:26.000Z","_content":"\n# 前端对接GPT实现打字机效果\n\n## 序言\n\n现在GPT可为非常火热，我们在这篇文章中将会研究如何通过 HTTP 请求和 SSE（Server-Sent Events）协议连接，并实现了基于流式 API 的长时间运行的聊天打字机效果，即用户输入一条消息后，模型逐步返回一个完整的对话内容。\n\n## 分析原因\n\n首先我们看看正常的api请求都是都是需要后端处理完成数据后，把数据打包好再一次性发送到前端。 但是由于GPT需要完成所有文字的生成之后才会进行返回，神经网络生成长文章可能需要15s甚至更长的时间，所以我们可以看到如果GPT生成返回的内容越多，接口返回的速度就回越慢。平均返回时间一般可以达到15s以上。而且由于网络、墙等问题，很容易让用户产生是否接口请求失败了，于是刷新页面重新请求的操作。\n\n![image](https://user-images.githubusercontent.com/2912039/230705256-a310aff3-9afa-4481-b792-5753250ef08f.png)\n\n由于GPT内容生成模型是以token为单位进行内容生成的，即不需要等待所有内容生成完成即可有数据返回。这时我们可以使用GPT api提供的stream参数，这个参数会让GPT立刻返回新生成的token内容，服务器会把token作为纯数据向客户端发送事件，就像在 ChatGPT 中一样，如果内容发送完成了，将以data: [DONE]结束。\n\n![image](https://user-images.githubusercontent.com/2912039/230705309-e4767ebf-fa99-4e90-ac1d-34bb789dadfb.png)\n\n这样我们就可以在GPT生成第一个token的时候即可以得到数据反馈并进行展示，减少了用户的等待时间，极大提升用户体验。如下图中，我们测试的问题只用了1.37s即有第一批token返回。\n\n![image](https://user-images.githubusercontent.com/2912039/230705329-7423be3c-8a89-4597-93a5-7ac8f5dec34e.png)\n\n在我们了解了优化方式之后，我们就可以开始进行撸代码了。\n\n## 前端实现\n\n那么我们需要怎么在前端去接受这种SSE的请求呢？简单的SSE GET请求可以通过EventSource来实现。但是由于GPT的chat和completions接口都是POST请求，所以我们需要稍微绕一下弯路，通过fetch来实现。下面直接上代码。\n\n```javascript\nconst response = await fetch('http://localhost:8080/api/chatGPT/chat', {\n  method: 'POST',\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({\n    messages,\n    ...config,\n  }),\n})\n\n// 创建 Reader 对象\nconst reader = response?.body?.getReader();\n// 创建解码器\nconst decoder = new TextDecoder(\"utf-8\");\nlet result = ''\nconst readChunk = async () => {\n  // 读取服务器返回的字符串数据\n  return reader?.read().then(({ value, done }) => {\n    if (!done) {\n      const dataString = decoder.decode(value);\n      // 循环读取字符串的内容。\n      dataString.toString().trim().split(\"data: \").forEach(async (line) => {\n        if (line !== '') {\n          // 去掉标识符 data:\n          const text = line.replace(\"data: \", \"\")\n          try {\n            // 转化为 js Object\n            const data = JSON.parse(text)\n            console.log(data.choices[0])\n            if (data.choices[0].delta.content) {\n              // 获取返回的内容，即token\n              result += data.choices[0].delta.content\n              // 保存并更新渲染\n              const resList = _.cloneDeep(newList)\n              resList[resList.length - 1] = {\n                content: marked.parse(result),\n                role: 'assistant'\n              }\n              setTextList(resList)\n            }\n            if (data.choices[0].finish_reason === 'length') {\n              // 长度限制了，可以再次请求更新\n              console.log('token 不足，请再次提交')\n              setChatLoading(false)\n              return\n            } else if (data.choices[0].finish_reason === 'stop') {\n              // 遇到停止符，GPT不再生成内容\n              // 保存并更新渲染\n              const resList = _.cloneDeep(newList)\n              resList[resList.length - 1] = {\n                content: marked.parse(result),\n                role: 'assistant'\n              }\n              setTextList(resList)\n              setChatLoading(false)\n              return\n            }\n            return readChunk();\n          } catch (error) {\n            // 流结束了，但是没有错误错误。\n            // 可能是 createCompletion 的 DONE 消息\n            console.error(error)\n            console.log(text)\n            if (text.trim() === '[DONE]') {\n              // GPT 已经生成完了所有内容\n              // 保存并更新渲染\n              const resList = _.cloneDeep(newList)\n              resList[resList.length - 1] = {\n                content: marked.parse(result),\n                role: 'assistant'\n              }\n              setTextList(resList)\n              return\n            }\n            setChatLoading(false)\n          }\n        }\n        // 保持一直滚动到最下方\n        setTimeout(() => {\n          let scroll_to_bottom = document.getElementById('chat_gpt_text_list');\n          scroll_to_bottom?.scroll({top: scroll_to_bottom.scrollHeight, behavior: \"smooth\"})\n        }, 50)\n      })\n    } else {\n      // 流读完了，结束\n      console.log(\"done\");\n    }\n  });\n};\n\nawait readChunk();\n```\n\n这里使用了 marked.js 库，用于将 Markdown 格式文本转换为 HTML 格式。\n\n通过 fetch 向 Node.js 服务器发送一个POST请求包含用户第一条消息内容的 JSON 对象，并将 HTTP 响应的流数据解析为字符串并逐行处理。\n\n在每次从流中读取到的新数据中，将 JSON 字符串解析为对象后提取出模型生成的回复文本，并使用 marked.js 将其转换为 HTML 文本。\n\n当模型返回的 finish_reason 字段为 \"stop\" 或者 \"length\" 时，停止递归调用 readChunk() 函数并更新 React 中 state 的状态，触发更新渲染。\n\n## koa后端\n实现完前端，我们再来看看后端代码实现。这里就简单用koa做一个代理转发，其实也可以前端直接调用GPT api的地址。但是由于GPT和国内双向屏蔽，所以还是部署一个国外的服务器比较省心。\n\n下面是koa端的Service层代码。引用了openai的包，并按照GPT api的接口文档进行对接。\n\n```javascript\nconst { Configuration, OpenAIApi } = require('openai');\n\n\nconst configuration = new Configuration({\n  organization: process.env.OPENAI_API_ORGANIZATION,\n  apiKey: process.env.OPENAI_API_KEY,\n});\nconst openai = new OpenAIApi(configuration);\n\nconst createCompletion = async (params) => {\n  const response = await openai.createCompletion({\n    model: params.model || \"text-davinci-003\",\n    prompt: params.prompt,\n    temperature: params.temperature || 0.9,\n    max_tokens: params.max_tokens || 200,\n    top_p: params.top_p || 1,\n    frequency_penalty: 0,\n    presence_penalty: 0,\n  });\n  return response.data.choices[0].text\n}\n\nconst createChatCompletion = async (params) => {\n  const response = await openai.createChatCompletion({\n    model: params.model || 'gpt-3.5-turbo',\n    messages: params.messages || [],\n    temperature: params.temperature || 0.9,\n    max_tokens: params.max_tokens || 200,\n    top_p: params.top_p || 1,\n    frequency_penalty: 0,\n    presence_penalty: 0,\n    stream: true\n  }, { responseType: 'stream' })\n  return response.data\n}\n\nconst createImage = async (params) => {\n  const response = await openai.createImage({\n    prompt: params.prompt,\n    n: 1,\n    size: '512x512'\n  });\n  return response.data.data\n}\n\nconst getListModels = async (params) => {\n  const response = await openai.listModels();\n  return response.data\n}\n\nmodule.exports = {\n  createCompletion,\n  createChatCompletion,\n  createImage,\n  getListModels\n};\n```\n\n下面是koa的Controller层的代码，定义了一些返回包体的结构\n\n```javascript\nconst { createCompletion: createCompletionHelper, createChatCompletion: createChatCompletionHelper, getListModels: getListModelsHelper, createImage: createImageHelper } = require('../helpers/chatGPT.helpers');\nconst ErrorShowType = {\n  SILENT: 0,\n  WARN_MESSAGE: 1,\n  ERROR_MESSAGE: 2,\n  NOTIFICATION: 3,\n  REDIRECT: 9,\n}\n\nconst createCompletion = async (ctx) => {\n  try {\n    ctx.body = {\n      success: true,\n      data: await createCompletionHelper(ctx.request.body)\n    }\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\nconst createChatCompletion = async (ctx) => {\n  try {\n    ctx.body = await createChatCompletionHelper(ctx.request.body)\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\n\nconst createImage = async (ctx) => {\n  try {\n    ctx.body = {\n      success: true,\n      data: await createImageHelper(ctx.request.body)\n    }\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\nconst getListModels = async (ctx) => {\n  try {\n    ctx.body = {\n      success: true,\n      data: await getListModelsHelper()\n    }\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\nmodule.exports = {\n  createCompletion,\n  createChatCompletion,\n  createImage,\n  getListModels\n};\n```\n\n这个时候，我们就已经完成了GPT的对接以及前端实现快速响应，以及打字机展示结果的展示效果。这个是我最近对GPT的一些前端研究，希望各位如果有什么更新颖的想法以及应用，欢迎交流。\n\n本文的代码都会放在 <https://github.com/zjw93615/gtp-demo> 仓库中，欢迎各位查漏补缺。\n\n","source":"_posts/杂谈/前端对接GPT实现打字机效果.md","raw":"---\ntitle: 前端对接GPT实现打字机效果\ntags:\n  - ChatGPT\n  - nodejs\n  - SSE\ncategories:\n  - 杂谈\ndate: 2023-04-13 17:46:26\n---\n\n# 前端对接GPT实现打字机效果\n\n## 序言\n\n现在GPT可为非常火热，我们在这篇文章中将会研究如何通过 HTTP 请求和 SSE（Server-Sent Events）协议连接，并实现了基于流式 API 的长时间运行的聊天打字机效果，即用户输入一条消息后，模型逐步返回一个完整的对话内容。\n\n## 分析原因\n\n首先我们看看正常的api请求都是都是需要后端处理完成数据后，把数据打包好再一次性发送到前端。 但是由于GPT需要完成所有文字的生成之后才会进行返回，神经网络生成长文章可能需要15s甚至更长的时间，所以我们可以看到如果GPT生成返回的内容越多，接口返回的速度就回越慢。平均返回时间一般可以达到15s以上。而且由于网络、墙等问题，很容易让用户产生是否接口请求失败了，于是刷新页面重新请求的操作。\n\n![image](https://user-images.githubusercontent.com/2912039/230705256-a310aff3-9afa-4481-b792-5753250ef08f.png)\n\n由于GPT内容生成模型是以token为单位进行内容生成的，即不需要等待所有内容生成完成即可有数据返回。这时我们可以使用GPT api提供的stream参数，这个参数会让GPT立刻返回新生成的token内容，服务器会把token作为纯数据向客户端发送事件，就像在 ChatGPT 中一样，如果内容发送完成了，将以data: [DONE]结束。\n\n![image](https://user-images.githubusercontent.com/2912039/230705309-e4767ebf-fa99-4e90-ac1d-34bb789dadfb.png)\n\n这样我们就可以在GPT生成第一个token的时候即可以得到数据反馈并进行展示，减少了用户的等待时间，极大提升用户体验。如下图中，我们测试的问题只用了1.37s即有第一批token返回。\n\n![image](https://user-images.githubusercontent.com/2912039/230705329-7423be3c-8a89-4597-93a5-7ac8f5dec34e.png)\n\n在我们了解了优化方式之后，我们就可以开始进行撸代码了。\n\n## 前端实现\n\n那么我们需要怎么在前端去接受这种SSE的请求呢？简单的SSE GET请求可以通过EventSource来实现。但是由于GPT的chat和completions接口都是POST请求，所以我们需要稍微绕一下弯路，通过fetch来实现。下面直接上代码。\n\n```javascript\nconst response = await fetch('http://localhost:8080/api/chatGPT/chat', {\n  method: 'POST',\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({\n    messages,\n    ...config,\n  }),\n})\n\n// 创建 Reader 对象\nconst reader = response?.body?.getReader();\n// 创建解码器\nconst decoder = new TextDecoder(\"utf-8\");\nlet result = ''\nconst readChunk = async () => {\n  // 读取服务器返回的字符串数据\n  return reader?.read().then(({ value, done }) => {\n    if (!done) {\n      const dataString = decoder.decode(value);\n      // 循环读取字符串的内容。\n      dataString.toString().trim().split(\"data: \").forEach(async (line) => {\n        if (line !== '') {\n          // 去掉标识符 data:\n          const text = line.replace(\"data: \", \"\")\n          try {\n            // 转化为 js Object\n            const data = JSON.parse(text)\n            console.log(data.choices[0])\n            if (data.choices[0].delta.content) {\n              // 获取返回的内容，即token\n              result += data.choices[0].delta.content\n              // 保存并更新渲染\n              const resList = _.cloneDeep(newList)\n              resList[resList.length - 1] = {\n                content: marked.parse(result),\n                role: 'assistant'\n              }\n              setTextList(resList)\n            }\n            if (data.choices[0].finish_reason === 'length') {\n              // 长度限制了，可以再次请求更新\n              console.log('token 不足，请再次提交')\n              setChatLoading(false)\n              return\n            } else if (data.choices[0].finish_reason === 'stop') {\n              // 遇到停止符，GPT不再生成内容\n              // 保存并更新渲染\n              const resList = _.cloneDeep(newList)\n              resList[resList.length - 1] = {\n                content: marked.parse(result),\n                role: 'assistant'\n              }\n              setTextList(resList)\n              setChatLoading(false)\n              return\n            }\n            return readChunk();\n          } catch (error) {\n            // 流结束了，但是没有错误错误。\n            // 可能是 createCompletion 的 DONE 消息\n            console.error(error)\n            console.log(text)\n            if (text.trim() === '[DONE]') {\n              // GPT 已经生成完了所有内容\n              // 保存并更新渲染\n              const resList = _.cloneDeep(newList)\n              resList[resList.length - 1] = {\n                content: marked.parse(result),\n                role: 'assistant'\n              }\n              setTextList(resList)\n              return\n            }\n            setChatLoading(false)\n          }\n        }\n        // 保持一直滚动到最下方\n        setTimeout(() => {\n          let scroll_to_bottom = document.getElementById('chat_gpt_text_list');\n          scroll_to_bottom?.scroll({top: scroll_to_bottom.scrollHeight, behavior: \"smooth\"})\n        }, 50)\n      })\n    } else {\n      // 流读完了，结束\n      console.log(\"done\");\n    }\n  });\n};\n\nawait readChunk();\n```\n\n这里使用了 marked.js 库，用于将 Markdown 格式文本转换为 HTML 格式。\n\n通过 fetch 向 Node.js 服务器发送一个POST请求包含用户第一条消息内容的 JSON 对象，并将 HTTP 响应的流数据解析为字符串并逐行处理。\n\n在每次从流中读取到的新数据中，将 JSON 字符串解析为对象后提取出模型生成的回复文本，并使用 marked.js 将其转换为 HTML 文本。\n\n当模型返回的 finish_reason 字段为 \"stop\" 或者 \"length\" 时，停止递归调用 readChunk() 函数并更新 React 中 state 的状态，触发更新渲染。\n\n## koa后端\n实现完前端，我们再来看看后端代码实现。这里就简单用koa做一个代理转发，其实也可以前端直接调用GPT api的地址。但是由于GPT和国内双向屏蔽，所以还是部署一个国外的服务器比较省心。\n\n下面是koa端的Service层代码。引用了openai的包，并按照GPT api的接口文档进行对接。\n\n```javascript\nconst { Configuration, OpenAIApi } = require('openai');\n\n\nconst configuration = new Configuration({\n  organization: process.env.OPENAI_API_ORGANIZATION,\n  apiKey: process.env.OPENAI_API_KEY,\n});\nconst openai = new OpenAIApi(configuration);\n\nconst createCompletion = async (params) => {\n  const response = await openai.createCompletion({\n    model: params.model || \"text-davinci-003\",\n    prompt: params.prompt,\n    temperature: params.temperature || 0.9,\n    max_tokens: params.max_tokens || 200,\n    top_p: params.top_p || 1,\n    frequency_penalty: 0,\n    presence_penalty: 0,\n  });\n  return response.data.choices[0].text\n}\n\nconst createChatCompletion = async (params) => {\n  const response = await openai.createChatCompletion({\n    model: params.model || 'gpt-3.5-turbo',\n    messages: params.messages || [],\n    temperature: params.temperature || 0.9,\n    max_tokens: params.max_tokens || 200,\n    top_p: params.top_p || 1,\n    frequency_penalty: 0,\n    presence_penalty: 0,\n    stream: true\n  }, { responseType: 'stream' })\n  return response.data\n}\n\nconst createImage = async (params) => {\n  const response = await openai.createImage({\n    prompt: params.prompt,\n    n: 1,\n    size: '512x512'\n  });\n  return response.data.data\n}\n\nconst getListModels = async (params) => {\n  const response = await openai.listModels();\n  return response.data\n}\n\nmodule.exports = {\n  createCompletion,\n  createChatCompletion,\n  createImage,\n  getListModels\n};\n```\n\n下面是koa的Controller层的代码，定义了一些返回包体的结构\n\n```javascript\nconst { createCompletion: createCompletionHelper, createChatCompletion: createChatCompletionHelper, getListModels: getListModelsHelper, createImage: createImageHelper } = require('../helpers/chatGPT.helpers');\nconst ErrorShowType = {\n  SILENT: 0,\n  WARN_MESSAGE: 1,\n  ERROR_MESSAGE: 2,\n  NOTIFICATION: 3,\n  REDIRECT: 9,\n}\n\nconst createCompletion = async (ctx) => {\n  try {\n    ctx.body = {\n      success: true,\n      data: await createCompletionHelper(ctx.request.body)\n    }\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\nconst createChatCompletion = async (ctx) => {\n  try {\n    ctx.body = await createChatCompletionHelper(ctx.request.body)\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\n\nconst createImage = async (ctx) => {\n  try {\n    ctx.body = {\n      success: true,\n      data: await createImageHelper(ctx.request.body)\n    }\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\nconst getListModels = async (ctx) => {\n  try {\n    ctx.body = {\n      success: true,\n      data: await getListModelsHelper()\n    }\n    ctx.status = 200;\n  } catch (err) {\n    console.log(err);\n    ctx.body = {\n      success: false,\n      data: null,\n      errorCode: 500,\n      errorMessage: err,\n      showType: ErrorShowType.ERROR_MESSAGE,\n    };\n    ctx.status = 500;\n  }\n};\n\nmodule.exports = {\n  createCompletion,\n  createChatCompletion,\n  createImage,\n  getListModels\n};\n```\n\n这个时候，我们就已经完成了GPT的对接以及前端实现快速响应，以及打字机展示结果的展示效果。这个是我最近对GPT的一些前端研究，希望各位如果有什么更新颖的想法以及应用，欢迎交流。\n\n本文的代码都会放在 <https://github.com/zjw93615/gtp-demo> 仓库中，欢迎各位查漏补缺。\n\n","slug":"杂谈/前端对接GPT实现打字机效果","published":1,"updated":"2023-04-13T09:54:44.498Z","_id":"clgey1jv0000gfpc3aor31675","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前端对接GPT实现打字机效果\"><a href=\"#前端对接GPT实现打字机效果\" class=\"headerlink\" title=\"前端对接GPT实现打字机效果\"></a>前端对接GPT实现打字机效果</h1><h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>现在GPT可为非常火热，我们在这篇文章中将会研究如何通过 HTTP 请求和 SSE（Server-Sent Events）协议连接，并实现了基于流式 API 的长时间运行的聊天打字机效果，即用户输入一条消息后，模型逐步返回一个完整的对话内容。</p>\n<h2 id=\"分析原因\"><a href=\"#分析原因\" class=\"headerlink\" title=\"分析原因\"></a>分析原因</h2><p>首先我们看看正常的api请求都是都是需要后端处理完成数据后，把数据打包好再一次性发送到前端。 但是由于GPT需要完成所有文字的生成之后才会进行返回，神经网络生成长文章可能需要15s甚至更长的时间，所以我们可以看到如果GPT生成返回的内容越多，接口返回的速度就回越慢。平均返回时间一般可以达到15s以上。而且由于网络、墙等问题，很容易让用户产生是否接口请求失败了，于是刷新页面重新请求的操作。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230705256-a310aff3-9afa-4481-b792-5753250ef08f.png\" alt=\"image\"></p>\n<p>由于GPT内容生成模型是以token为单位进行内容生成的，即不需要等待所有内容生成完成即可有数据返回。这时我们可以使用GPT api提供的stream参数，这个参数会让GPT立刻返回新生成的token内容，服务器会把token作为纯数据向客户端发送事件，就像在 ChatGPT 中一样，如果内容发送完成了，将以data: [DONE]结束。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230705309-e4767ebf-fa99-4e90-ac1d-34bb789dadfb.png\" alt=\"image\"></p>\n<p>这样我们就可以在GPT生成第一个token的时候即可以得到数据反馈并进行展示，减少了用户的等待时间，极大提升用户体验。如下图中，我们测试的问题只用了1.37s即有第一批token返回。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230705329-7423be3c-8a89-4597-93a5-7ac8f5dec34e.png\" alt=\"image\"></p>\n<p>在我们了解了优化方式之后，我们就可以开始进行撸代码了。</p>\n<h2 id=\"前端实现\"><a href=\"#前端实现\" class=\"headerlink\" title=\"前端实现\"></a>前端实现</h2><p>那么我们需要怎么在前端去接受这种SSE的请求呢？简单的SSE GET请求可以通过EventSource来实现。但是由于GPT的chat和completions接口都是POST请求，所以我们需要稍微绕一下弯路，通过fetch来实现。下面直接上代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/api/chatGPT/chat&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,<br>  <span class=\"hljs-attr\">headers</span>: &#123;<br>    <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: <span class=\"hljs-string\">&quot;application/json&quot;</span>,<br>  &#125;,<br>  <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(&#123;<br>    messages,<br>    ...config,<br>  &#125;),<br>&#125;)<br><br><span class=\"hljs-comment\">// 创建 Reader 对象</span><br><span class=\"hljs-keyword\">const</span> reader = response?.<span class=\"hljs-property\">body</span>?.<span class=\"hljs-title function_\">getReader</span>();<br><span class=\"hljs-comment\">// 创建解码器</span><br><span class=\"hljs-keyword\">const</span> decoder = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TextDecoder</span>(<span class=\"hljs-string\">&quot;utf-8&quot;</span>);<br><span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-string\">&#x27;&#x27;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">readChunk</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-comment\">// 读取服务器返回的字符串数据</span><br>  <span class=\"hljs-keyword\">return</span> reader?.<span class=\"hljs-title function_\">read</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; value, done &#125;</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!done) &#123;<br>      <span class=\"hljs-keyword\">const</span> dataString = decoder.<span class=\"hljs-title function_\">decode</span>(value);<br>      <span class=\"hljs-comment\">// 循环读取字符串的内容。</span><br>      dataString.<span class=\"hljs-title function_\">toString</span>().<span class=\"hljs-title function_\">trim</span>().<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;data: &quot;</span>).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">async</span> (line) =&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span> (line !== <span class=\"hljs-string\">&#x27;&#x27;</span>) &#123;<br>          <span class=\"hljs-comment\">// 去掉标识符 data:</span><br>          <span class=\"hljs-keyword\">const</span> text = line.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&quot;data: &quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>)<br>          <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 转化为 js Object</span><br>            <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(text)<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>])<br>            <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">delta</span>.<span class=\"hljs-property\">content</span>) &#123;<br>              <span class=\"hljs-comment\">// 获取返回的内容，即token</span><br>              result += data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">delta</span>.<span class=\"hljs-property\">content</span><br>              <span class=\"hljs-comment\">// 保存并更新渲染</span><br>              <span class=\"hljs-keyword\">const</span> resList = _.<span class=\"hljs-title function_\">cloneDeep</span>(newList)<br>              resList[resList.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>] = &#123;<br>                <span class=\"hljs-attr\">content</span>: marked.<span class=\"hljs-title function_\">parse</span>(result),<br>                <span class=\"hljs-attr\">role</span>: <span class=\"hljs-string\">&#x27;assistant&#x27;</span><br>              &#125;<br>              <span class=\"hljs-title function_\">setTextList</span>(resList)<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">finish_reason</span> === <span class=\"hljs-string\">&#x27;length&#x27;</span>) &#123;<br>              <span class=\"hljs-comment\">// 长度限制了，可以再次请求更新</span><br>              <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;token 不足，请再次提交&#x27;</span>)<br>              <span class=\"hljs-title function_\">setChatLoading</span>(<span class=\"hljs-literal\">false</span>)<br>              <span class=\"hljs-keyword\">return</span><br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">finish_reason</span> === <span class=\"hljs-string\">&#x27;stop&#x27;</span>) &#123;<br>              <span class=\"hljs-comment\">// 遇到停止符，GPT不再生成内容</span><br>              <span class=\"hljs-comment\">// 保存并更新渲染</span><br>              <span class=\"hljs-keyword\">const</span> resList = _.<span class=\"hljs-title function_\">cloneDeep</span>(newList)<br>              resList[resList.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>] = &#123;<br>                <span class=\"hljs-attr\">content</span>: marked.<span class=\"hljs-title function_\">parse</span>(result),<br>                <span class=\"hljs-attr\">role</span>: <span class=\"hljs-string\">&#x27;assistant&#x27;</span><br>              &#125;<br>              <span class=\"hljs-title function_\">setTextList</span>(resList)<br>              <span class=\"hljs-title function_\">setChatLoading</span>(<span class=\"hljs-literal\">false</span>)<br>              <span class=\"hljs-keyword\">return</span><br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">readChunk</span>();<br>          &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>            <span class=\"hljs-comment\">// 流结束了，但是没有错误错误。</span><br>            <span class=\"hljs-comment\">// 可能是 createCompletion 的 DONE 消息</span><br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error)<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(text)<br>            <span class=\"hljs-keyword\">if</span> (text.<span class=\"hljs-title function_\">trim</span>() === <span class=\"hljs-string\">&#x27;[DONE]&#x27;</span>) &#123;<br>              <span class=\"hljs-comment\">// GPT 已经生成完了所有内容</span><br>              <span class=\"hljs-comment\">// 保存并更新渲染</span><br>              <span class=\"hljs-keyword\">const</span> resList = _.<span class=\"hljs-title function_\">cloneDeep</span>(newList)<br>              resList[resList.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>] = &#123;<br>                <span class=\"hljs-attr\">content</span>: marked.<span class=\"hljs-title function_\">parse</span>(result),<br>                <span class=\"hljs-attr\">role</span>: <span class=\"hljs-string\">&#x27;assistant&#x27;</span><br>              &#125;<br>              <span class=\"hljs-title function_\">setTextList</span>(resList)<br>              <span class=\"hljs-keyword\">return</span><br>            &#125;<br>            <span class=\"hljs-title function_\">setChatLoading</span>(<span class=\"hljs-literal\">false</span>)<br>          &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 保持一直滚动到最下方</span><br>        <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">let</span> scroll_to_bottom = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;chat_gpt_text_list&#x27;</span>);<br>          scroll_to_bottom?.<span class=\"hljs-title function_\">scroll</span>(&#123;<span class=\"hljs-attr\">top</span>: scroll_to_bottom.<span class=\"hljs-property\">scrollHeight</span>, <span class=\"hljs-attr\">behavior</span>: <span class=\"hljs-string\">&quot;smooth&quot;</span>&#125;)<br>        &#125;, <span class=\"hljs-number\">50</span>)<br>      &#125;)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 流读完了，结束</span><br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;done&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br><span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readChunk</span>();<br></code></pre></td></tr></table></figure>\n\n<p>这里使用了 marked.js 库，用于将 Markdown 格式文本转换为 HTML 格式。</p>\n<p>通过 fetch 向 Node.js 服务器发送一个POST请求包含用户第一条消息内容的 JSON 对象，并将 HTTP 响应的流数据解析为字符串并逐行处理。</p>\n<p>在每次从流中读取到的新数据中，将 JSON 字符串解析为对象后提取出模型生成的回复文本，并使用 marked.js 将其转换为 HTML 文本。</p>\n<p>当模型返回的 finish_reason 字段为 “stop” 或者 “length” 时，停止递归调用 readChunk() 函数并更新 React 中 state 的状态，触发更新渲染。</p>\n<h2 id=\"koa后端\"><a href=\"#koa后端\" class=\"headerlink\" title=\"koa后端\"></a>koa后端</h2><p>实现完前端，我们再来看看后端代码实现。这里就简单用koa做一个代理转发，其实也可以前端直接调用GPT api的地址。但是由于GPT和国内双向屏蔽，所以还是部署一个国外的服务器比较省心。</p>\n<p>下面是koa端的Service层代码。引用了openai的包，并按照GPT api的接口文档进行对接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">Configuration</span>, <span class=\"hljs-title class_\">OpenAIApi</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;openai&#x27;</span>);<br><br><br><span class=\"hljs-keyword\">const</span> configuration = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Configuration</span>(&#123;<br>  <span class=\"hljs-attr\">organization</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">OPENAI_API_ORGANIZATION</span>,<br>  <span class=\"hljs-attr\">apiKey</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">OPENAI_API_KEY</span>,<br>&#125;);<br><span class=\"hljs-keyword\">const</span> openai = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenAIApi</span>(configuration);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">createCompletion</span>(&#123;<br>    <span class=\"hljs-attr\">model</span>: params.<span class=\"hljs-property\">model</span> || <span class=\"hljs-string\">&quot;text-davinci-003&quot;</span>,<br>    <span class=\"hljs-attr\">prompt</span>: params.<span class=\"hljs-property\">prompt</span>,<br>    <span class=\"hljs-attr\">temperature</span>: params.<span class=\"hljs-property\">temperature</span> || <span class=\"hljs-number\">0.9</span>,<br>    <span class=\"hljs-attr\">max_tokens</span>: params.<span class=\"hljs-property\">max_tokens</span> || <span class=\"hljs-number\">200</span>,<br>    <span class=\"hljs-attr\">top_p</span>: params.<span class=\"hljs-property\">top_p</span> || <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">frequency_penalty</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">presence_penalty</span>: <span class=\"hljs-number\">0</span>,<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">text</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createChatCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">createChatCompletion</span>(&#123;<br>    <span class=\"hljs-attr\">model</span>: params.<span class=\"hljs-property\">model</span> || <span class=\"hljs-string\">&#x27;gpt-3.5-turbo&#x27;</span>,<br>    <span class=\"hljs-attr\">messages</span>: params.<span class=\"hljs-property\">messages</span> || [],<br>    <span class=\"hljs-attr\">temperature</span>: params.<span class=\"hljs-property\">temperature</span> || <span class=\"hljs-number\">0.9</span>,<br>    <span class=\"hljs-attr\">max_tokens</span>: params.<span class=\"hljs-property\">max_tokens</span> || <span class=\"hljs-number\">200</span>,<br>    <span class=\"hljs-attr\">top_p</span>: params.<span class=\"hljs-property\">top_p</span> || <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">frequency_penalty</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">presence_penalty</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-literal\">true</span><br>  &#125;, &#123; <span class=\"hljs-attr\">responseType</span>: <span class=\"hljs-string\">&#x27;stream&#x27;</span> &#125;)<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createImage</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">createImage</span>(&#123;<br>    <span class=\"hljs-attr\">prompt</span>: params.<span class=\"hljs-property\">prompt</span>,<br>    <span class=\"hljs-attr\">n</span>: <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">size</span>: <span class=\"hljs-string\">&#x27;512x512&#x27;</span><br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">data</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getListModels</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">listModels</span>();<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span><br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  createCompletion,<br>  createChatCompletion,<br>  createImage,<br>  getListModels<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>下面是koa的Controller层的代码，定义了一些返回包体的结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">createCompletion</span>: createCompletionHelper, <span class=\"hljs-attr\">createChatCompletion</span>: createChatCompletionHelper, <span class=\"hljs-attr\">getListModels</span>: getListModelsHelper, <span class=\"hljs-attr\">createImage</span>: createImageHelper &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;../helpers/chatGPT.helpers&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ErrorShowType</span> = &#123;<br>  <span class=\"hljs-attr\">SILENT</span>: <span class=\"hljs-number\">0</span>,<br>  <span class=\"hljs-attr\">WARN_MESSAGE</span>: <span class=\"hljs-number\">1</span>,<br>  <span class=\"hljs-attr\">ERROR_MESSAGE</span>: <span class=\"hljs-number\">2</span>,<br>  <span class=\"hljs-attr\">NOTIFICATION</span>: <span class=\"hljs-number\">3</span>,<br>  <span class=\"hljs-attr\">REDIRECT</span>: <span class=\"hljs-number\">9</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">createCompletionHelper</span>(ctx.<span class=\"hljs-property\">request</span>.<span class=\"hljs-property\">body</span>)<br>    &#125;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createChatCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">createChatCompletionHelper</span>(ctx.<span class=\"hljs-property\">request</span>.<span class=\"hljs-property\">body</span>)<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createImage</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">createImageHelper</span>(ctx.<span class=\"hljs-property\">request</span>.<span class=\"hljs-property\">body</span>)<br>    &#125;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getListModels</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getListModelsHelper</span>()<br>    &#125;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  createCompletion,<br>  createChatCompletion,<br>  createImage,<br>  getListModels<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这个时候，我们就已经完成了GPT的对接以及前端实现快速响应，以及打字机展示结果的展示效果。这个是我最近对GPT的一些前端研究，希望各位如果有什么更新颖的想法以及应用，欢迎交流。</p>\n<p>本文的代码都会放在 <a href=\"https://github.com/zjw93615/gtp-demo\">https://github.com/zjw93615/gtp-demo</a> 仓库中，欢迎各位查漏补缺。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端对接GPT实现打字机效果\"><a href=\"#前端对接GPT实现打字机效果\" class=\"headerlink\" title=\"前端对接GPT实现打字机效果\"></a>前端对接GPT实现打字机效果</h1><h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>现在GPT可为非常火热，我们在这篇文章中将会研究如何通过 HTTP 请求和 SSE（Server-Sent Events）协议连接，并实现了基于流式 API 的长时间运行的聊天打字机效果，即用户输入一条消息后，模型逐步返回一个完整的对话内容。</p>\n<h2 id=\"分析原因\"><a href=\"#分析原因\" class=\"headerlink\" title=\"分析原因\"></a>分析原因</h2><p>首先我们看看正常的api请求都是都是需要后端处理完成数据后，把数据打包好再一次性发送到前端。 但是由于GPT需要完成所有文字的生成之后才会进行返回，神经网络生成长文章可能需要15s甚至更长的时间，所以我们可以看到如果GPT生成返回的内容越多，接口返回的速度就回越慢。平均返回时间一般可以达到15s以上。而且由于网络、墙等问题，很容易让用户产生是否接口请求失败了，于是刷新页面重新请求的操作。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230705256-a310aff3-9afa-4481-b792-5753250ef08f.png\" alt=\"image\"></p>\n<p>由于GPT内容生成模型是以token为单位进行内容生成的，即不需要等待所有内容生成完成即可有数据返回。这时我们可以使用GPT api提供的stream参数，这个参数会让GPT立刻返回新生成的token内容，服务器会把token作为纯数据向客户端发送事件，就像在 ChatGPT 中一样，如果内容发送完成了，将以data: [DONE]结束。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230705309-e4767ebf-fa99-4e90-ac1d-34bb789dadfb.png\" alt=\"image\"></p>\n<p>这样我们就可以在GPT生成第一个token的时候即可以得到数据反馈并进行展示，减少了用户的等待时间，极大提升用户体验。如下图中，我们测试的问题只用了1.37s即有第一批token返回。</p>\n<p><img src=\"https://user-images.githubusercontent.com/2912039/230705329-7423be3c-8a89-4597-93a5-7ac8f5dec34e.png\" alt=\"image\"></p>\n<p>在我们了解了优化方式之后，我们就可以开始进行撸代码了。</p>\n<h2 id=\"前端实现\"><a href=\"#前端实现\" class=\"headerlink\" title=\"前端实现\"></a>前端实现</h2><p>那么我们需要怎么在前端去接受这种SSE的请求呢？简单的SSE GET请求可以通过EventSource来实现。但是由于GPT的chat和completions接口都是POST请求，所以我们需要稍微绕一下弯路，通过fetch来实现。下面直接上代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;http://localhost:8080/api/chatGPT/chat&#x27;</span>, &#123;<br>  <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,<br>  <span class=\"hljs-attr\">headers</span>: &#123;<br>    <span class=\"hljs-string\">&quot;Content-Type&quot;</span>: <span class=\"hljs-string\">&quot;application/json&quot;</span>,<br>  &#125;,<br>  <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(&#123;<br>    messages,<br>    ...config,<br>  &#125;),<br>&#125;)<br><br><span class=\"hljs-comment\">// 创建 Reader 对象</span><br><span class=\"hljs-keyword\">const</span> reader = response?.<span class=\"hljs-property\">body</span>?.<span class=\"hljs-title function_\">getReader</span>();<br><span class=\"hljs-comment\">// 创建解码器</span><br><span class=\"hljs-keyword\">const</span> decoder = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TextDecoder</span>(<span class=\"hljs-string\">&quot;utf-8&quot;</span>);<br><span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-string\">&#x27;&#x27;</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">readChunk</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\"></span>) =&gt; &#123;<br>  <span class=\"hljs-comment\">// 读取服务器返回的字符串数据</span><br>  <span class=\"hljs-keyword\">return</span> reader?.<span class=\"hljs-title function_\">read</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">&#123; value, done &#125;</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!done) &#123;<br>      <span class=\"hljs-keyword\">const</span> dataString = decoder.<span class=\"hljs-title function_\">decode</span>(value);<br>      <span class=\"hljs-comment\">// 循环读取字符串的内容。</span><br>      dataString.<span class=\"hljs-title function_\">toString</span>().<span class=\"hljs-title function_\">trim</span>().<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot;data: &quot;</span>).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-keyword\">async</span> (line) =&gt; &#123;<br>        <span class=\"hljs-keyword\">if</span> (line !== <span class=\"hljs-string\">&#x27;&#x27;</span>) &#123;<br>          <span class=\"hljs-comment\">// 去掉标识符 data:</span><br>          <span class=\"hljs-keyword\">const</span> text = line.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">&quot;data: &quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>)<br>          <span class=\"hljs-keyword\">try</span> &#123;<br>            <span class=\"hljs-comment\">// 转化为 js Object</span><br>            <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">parse</span>(text)<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>])<br>            <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">delta</span>.<span class=\"hljs-property\">content</span>) &#123;<br>              <span class=\"hljs-comment\">// 获取返回的内容，即token</span><br>              result += data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">delta</span>.<span class=\"hljs-property\">content</span><br>              <span class=\"hljs-comment\">// 保存并更新渲染</span><br>              <span class=\"hljs-keyword\">const</span> resList = _.<span class=\"hljs-title function_\">cloneDeep</span>(newList)<br>              resList[resList.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>] = &#123;<br>                <span class=\"hljs-attr\">content</span>: marked.<span class=\"hljs-title function_\">parse</span>(result),<br>                <span class=\"hljs-attr\">role</span>: <span class=\"hljs-string\">&#x27;assistant&#x27;</span><br>              &#125;<br>              <span class=\"hljs-title function_\">setTextList</span>(resList)<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">finish_reason</span> === <span class=\"hljs-string\">&#x27;length&#x27;</span>) &#123;<br>              <span class=\"hljs-comment\">// 长度限制了，可以再次请求更新</span><br>              <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;token 不足，请再次提交&#x27;</span>)<br>              <span class=\"hljs-title function_\">setChatLoading</span>(<span class=\"hljs-literal\">false</span>)<br>              <span class=\"hljs-keyword\">return</span><br>            &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">finish_reason</span> === <span class=\"hljs-string\">&#x27;stop&#x27;</span>) &#123;<br>              <span class=\"hljs-comment\">// 遇到停止符，GPT不再生成内容</span><br>              <span class=\"hljs-comment\">// 保存并更新渲染</span><br>              <span class=\"hljs-keyword\">const</span> resList = _.<span class=\"hljs-title function_\">cloneDeep</span>(newList)<br>              resList[resList.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>] = &#123;<br>                <span class=\"hljs-attr\">content</span>: marked.<span class=\"hljs-title function_\">parse</span>(result),<br>                <span class=\"hljs-attr\">role</span>: <span class=\"hljs-string\">&#x27;assistant&#x27;</span><br>              &#125;<br>              <span class=\"hljs-title function_\">setTextList</span>(resList)<br>              <span class=\"hljs-title function_\">setChatLoading</span>(<span class=\"hljs-literal\">false</span>)<br>              <span class=\"hljs-keyword\">return</span><br>            &#125;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">readChunk</span>();<br>          &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>            <span class=\"hljs-comment\">// 流结束了，但是没有错误错误。</span><br>            <span class=\"hljs-comment\">// 可能是 createCompletion 的 DONE 消息</span><br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(error)<br>            <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(text)<br>            <span class=\"hljs-keyword\">if</span> (text.<span class=\"hljs-title function_\">trim</span>() === <span class=\"hljs-string\">&#x27;[DONE]&#x27;</span>) &#123;<br>              <span class=\"hljs-comment\">// GPT 已经生成完了所有内容</span><br>              <span class=\"hljs-comment\">// 保存并更新渲染</span><br>              <span class=\"hljs-keyword\">const</span> resList = _.<span class=\"hljs-title function_\">cloneDeep</span>(newList)<br>              resList[resList.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>] = &#123;<br>                <span class=\"hljs-attr\">content</span>: marked.<span class=\"hljs-title function_\">parse</span>(result),<br>                <span class=\"hljs-attr\">role</span>: <span class=\"hljs-string\">&#x27;assistant&#x27;</span><br>              &#125;<br>              <span class=\"hljs-title function_\">setTextList</span>(resList)<br>              <span class=\"hljs-keyword\">return</span><br>            &#125;<br>            <span class=\"hljs-title function_\">setChatLoading</span>(<span class=\"hljs-literal\">false</span>)<br>          &#125;<br>        &#125;<br>        <span class=\"hljs-comment\">// 保持一直滚动到最下方</span><br>        <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">let</span> scroll_to_bottom = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;chat_gpt_text_list&#x27;</span>);<br>          scroll_to_bottom?.<span class=\"hljs-title function_\">scroll</span>(&#123;<span class=\"hljs-attr\">top</span>: scroll_to_bottom.<span class=\"hljs-property\">scrollHeight</span>, <span class=\"hljs-attr\">behavior</span>: <span class=\"hljs-string\">&quot;smooth&quot;</span>&#125;)<br>        &#125;, <span class=\"hljs-number\">50</span>)<br>      &#125;)<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-comment\">// 流读完了，结束</span><br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;done&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><br><span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">readChunk</span>();<br></code></pre></td></tr></table></figure>\n\n<p>这里使用了 marked.js 库，用于将 Markdown 格式文本转换为 HTML 格式。</p>\n<p>通过 fetch 向 Node.js 服务器发送一个POST请求包含用户第一条消息内容的 JSON 对象，并将 HTTP 响应的流数据解析为字符串并逐行处理。</p>\n<p>在每次从流中读取到的新数据中，将 JSON 字符串解析为对象后提取出模型生成的回复文本，并使用 marked.js 将其转换为 HTML 文本。</p>\n<p>当模型返回的 finish_reason 字段为 “stop” 或者 “length” 时，停止递归调用 readChunk() 函数并更新 React 中 state 的状态，触发更新渲染。</p>\n<h2 id=\"koa后端\"><a href=\"#koa后端\" class=\"headerlink\" title=\"koa后端\"></a>koa后端</h2><p>实现完前端，我们再来看看后端代码实现。这里就简单用koa做一个代理转发，其实也可以前端直接调用GPT api的地址。但是由于GPT和国内双向屏蔽，所以还是部署一个国外的服务器比较省心。</p>\n<p>下面是koa端的Service层代码。引用了openai的包，并按照GPT api的接口文档进行对接。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-title class_\">Configuration</span>, <span class=\"hljs-title class_\">OpenAIApi</span> &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;openai&#x27;</span>);<br><br><br><span class=\"hljs-keyword\">const</span> configuration = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Configuration</span>(&#123;<br>  <span class=\"hljs-attr\">organization</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">OPENAI_API_ORGANIZATION</span>,<br>  <span class=\"hljs-attr\">apiKey</span>: process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">OPENAI_API_KEY</span>,<br>&#125;);<br><span class=\"hljs-keyword\">const</span> openai = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">OpenAIApi</span>(configuration);<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">createCompletion</span>(&#123;<br>    <span class=\"hljs-attr\">model</span>: params.<span class=\"hljs-property\">model</span> || <span class=\"hljs-string\">&quot;text-davinci-003&quot;</span>,<br>    <span class=\"hljs-attr\">prompt</span>: params.<span class=\"hljs-property\">prompt</span>,<br>    <span class=\"hljs-attr\">temperature</span>: params.<span class=\"hljs-property\">temperature</span> || <span class=\"hljs-number\">0.9</span>,<br>    <span class=\"hljs-attr\">max_tokens</span>: params.<span class=\"hljs-property\">max_tokens</span> || <span class=\"hljs-number\">200</span>,<br>    <span class=\"hljs-attr\">top_p</span>: params.<span class=\"hljs-property\">top_p</span> || <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">frequency_penalty</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">presence_penalty</span>: <span class=\"hljs-number\">0</span>,<br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">choices</span>[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">text</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createChatCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">createChatCompletion</span>(&#123;<br>    <span class=\"hljs-attr\">model</span>: params.<span class=\"hljs-property\">model</span> || <span class=\"hljs-string\">&#x27;gpt-3.5-turbo&#x27;</span>,<br>    <span class=\"hljs-attr\">messages</span>: params.<span class=\"hljs-property\">messages</span> || [],<br>    <span class=\"hljs-attr\">temperature</span>: params.<span class=\"hljs-property\">temperature</span> || <span class=\"hljs-number\">0.9</span>,<br>    <span class=\"hljs-attr\">max_tokens</span>: params.<span class=\"hljs-property\">max_tokens</span> || <span class=\"hljs-number\">200</span>,<br>    <span class=\"hljs-attr\">top_p</span>: params.<span class=\"hljs-property\">top_p</span> || <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">frequency_penalty</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">presence_penalty</span>: <span class=\"hljs-number\">0</span>,<br>    <span class=\"hljs-attr\">stream</span>: <span class=\"hljs-literal\">true</span><br>  &#125;, &#123; <span class=\"hljs-attr\">responseType</span>: <span class=\"hljs-string\">&#x27;stream&#x27;</span> &#125;)<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createImage</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">createImage</span>(&#123;<br>    <span class=\"hljs-attr\">prompt</span>: params.<span class=\"hljs-property\">prompt</span>,<br>    <span class=\"hljs-attr\">n</span>: <span class=\"hljs-number\">1</span>,<br>    <span class=\"hljs-attr\">size</span>: <span class=\"hljs-string\">&#x27;512x512&#x27;</span><br>  &#125;);<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span>.<span class=\"hljs-property\">data</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getListModels</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">params</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> openai.<span class=\"hljs-title function_\">listModels</span>();<br>  <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-property\">data</span><br>&#125;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  createCompletion,<br>  createChatCompletion,<br>  createImage,<br>  getListModels<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>下面是koa的Controller层的代码，定义了一些返回包体的结构</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">createCompletion</span>: createCompletionHelper, <span class=\"hljs-attr\">createChatCompletion</span>: createChatCompletionHelper, <span class=\"hljs-attr\">getListModels</span>: getListModelsHelper, <span class=\"hljs-attr\">createImage</span>: createImageHelper &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;../helpers/chatGPT.helpers&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">ErrorShowType</span> = &#123;<br>  <span class=\"hljs-attr\">SILENT</span>: <span class=\"hljs-number\">0</span>,<br>  <span class=\"hljs-attr\">WARN_MESSAGE</span>: <span class=\"hljs-number\">1</span>,<br>  <span class=\"hljs-attr\">ERROR_MESSAGE</span>: <span class=\"hljs-number\">2</span>,<br>  <span class=\"hljs-attr\">NOTIFICATION</span>: <span class=\"hljs-number\">3</span>,<br>  <span class=\"hljs-attr\">REDIRECT</span>: <span class=\"hljs-number\">9</span>,<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">createCompletionHelper</span>(ctx.<span class=\"hljs-property\">request</span>.<span class=\"hljs-property\">body</span>)<br>    &#125;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createChatCompletion</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">createChatCompletionHelper</span>(ctx.<span class=\"hljs-property\">request</span>.<span class=\"hljs-property\">body</span>)<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">createImage</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">createImageHelper</span>(ctx.<span class=\"hljs-property\">request</span>.<span class=\"hljs-property\">body</span>)<br>    &#125;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getListModels</span> = <span class=\"hljs-keyword\">async</span> (<span class=\"hljs-params\">ctx</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">getListModelsHelper</span>()<br>    &#125;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">200</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(err);<br>    ctx.<span class=\"hljs-property\">body</span> = &#123;<br>      <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>,<br>      <span class=\"hljs-attr\">data</span>: <span class=\"hljs-literal\">null</span>,<br>      <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">500</span>,<br>      <span class=\"hljs-attr\">errorMessage</span>: err,<br>      <span class=\"hljs-attr\">showType</span>: <span class=\"hljs-title class_\">ErrorShowType</span>.<span class=\"hljs-property\">ERROR_MESSAGE</span>,<br>    &#125;;<br>    ctx.<span class=\"hljs-property\">status</span> = <span class=\"hljs-number\">500</span>;<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  createCompletion,<br>  createChatCompletion,<br>  createImage,<br>  getListModels<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这个时候，我们就已经完成了GPT的对接以及前端实现快速响应，以及打字机展示结果的展示效果。这个是我最近对GPT的一些前端研究，希望各位如果有什么更新颖的想法以及应用，欢迎交流。</p>\n<p>本文的代码都会放在 <a href=\"https://github.com/zjw93615/gtp-demo\">https://github.com/zjw93615/gtp-demo</a> 仓库中，欢迎各位查漏补缺。</p>\n"},{"title":"使用patch-package修改第三方模块","date":"2023-04-14T06:57:26.000Z","_content":"\n# 使用patch-package修改第三方模块\n\n在我们日常开发中，经常会遇到一些情况就是引用的`npm包`并不能完全满足我们的需求，或者在某些情况下触发了bug使得组建的展示和行为不正常。这个时候，我们就需要去修改npm包的代码了。\n\n但是，我们知道，我们不能直接进入`node_modules`中去修改包的代码。因为如果我们在本地的`node_modules`中修改了代码，可能在我们本地可以正常运行，但是如果团队的其他人员进行开发，甚至于使用`ci/cd`去部署项目时，由于它会重新下载新的包，这样你的改动就不能在其他机器上生效。\n\n那么我们就来看看如何正确地修改`npm包`里面的内容，同时能够同步给其他开发人员，使得大家的`npm包`都是统一修改过的版本。\n\n## 安装 patch-package\n```shell\n# npm\nnpm install patch-package --save-dev\n```\n\n## 修改并调试\n\n一般我们可以直接在npm的官网找到对于的`github`地址，从而下载到源码。`需要注意的是，我们下载的源码必须要与我们项目中引用的版本相同。`我们就以`easy-log-report`这个包为例子，我们可以找到它的对应仓库在 [https://github.com/zjw93615/EasyLog](https://github.com/zjw93615/EasyLog) 。我们就把项目的文件下载到本地并且打开。 之后在根目录上按照依赖。\n\n```shell\nnpm install\n```\n\n接着当我们修改完文件之后，我们怎么知道我们的修改是否生效呢？是否符合我们原来的预期呢？首先我们把修改好的项目`build`一下，不同的项目可能有不同的`build`方式，详细的可以看看项目的`package.json`或者`README.md`看是否有相关的说明。\n\n```shell\nnpm run build\n```\n\n编译完成之后，我们可以通过`link命令`，把我们修改好的包本地链接到引入了这个包的项目中。\n\n```shell\ncd ~/projects/easy-log-report     # 需要修改的包的根目录\nnpm link                          # 创建全局的npm link\n\ncd ~/projects/foo                 # 假设这个foo项目引用了easy-log-report这个包，去到foo的根目录\nnpm link easy-log-report          # 把easy-log-report这个包本地链接到foo这个项目\n```\n\n这样我们启动foo这个项目，我们就可以看到我们对于`easy-log-report`这个包的修改已经生效了。\n\n## 创建补丁\n\n在上面一步，我们已经把包修改完成并且完成调试了，这时候我们就可以把build好的文件拷贝到`node_modules`中对于的文件夹中。在这个例子中我们需要把~/projects/easy-log-report/build文件夹中的文件拷贝到~/projects/foo/node_modules/easy-log-report/build这个文件夹中。然后回到根目录执行patch-package。\n\n```shell\n# npm > 5.2\nnpx patch-package easy-log-report\n```\n执行完成后，会在项目根目录的 `patches`目录中创建补丁文件 `easy-log-report+1.0.3.patch（1.0.3 是依赖包版本）`，`这个补丁需要提交到代码仓库中`。\n\n如果我们打开`.patch`文件，我们可以发现其实就是一些`git diff`记录描述，那么`patch-package`补丁原理呼之欲出——`patch-package`会将当前`node_modules`下的源码与原始源码进行`git diff`，并在项目根目录下生成一个`patch`补丁文件。\n\n### options\n--use-yarn\npatch-package 默认是根据项目中的 lockfile 来决定使用 npm 还是 yarn，如果两种都有，则使用 npm，可以通过这个参数启用 yarn\n\n--exclude <regexp>\n创建补丁文件时，忽略与正则表达式匹配的路径，路径相对于要修改的依赖包的根目录，默认: package\\\\.json$\n\n--include <regexp>\n与 --exclude <regexp> 相反，创建补丁文件时仅考虑与正则表达式匹配的路径，默认: .*\n\n--case-sensitive-path-filtering\n使 --include 或 --exclude 中使用的正则表达式区分大小写\n\n--patch-dir\n指定放置补丁文件的目录\n\n## 打补丁\n\n当其他同事拉到代码如何应用补丁呢？基于上述操作我们在`npm install`后执行`patch-package`命令即可。\n```shell\nnpx patch-package\n```\n\n### options\n--reverse\n撤回所有补丁\nNote: 如果打补丁后，补丁文件被修改过，此操作将失败，此时可以重新安装 node_modules\n\n--patch-dir\n指定补丁文件所在目录\n\n## 完善npm脚本\n这个流程可借助`npm script`实现，在`package.json`的`script`中添加如下字段及内容：\n```js\n{\n    \"postinstall\": \"patch-package\"\n}\n```\n\n这样我们后续执行 npm install 或 yarn install 命令时，会自动为依赖包打补丁了\n\n","source":"_posts/npm/使用patch-package修改第三方模块.md","raw":"---\ntitle: 使用patch-package修改第三方模块\ndate: 2023-04-14 14:57:26\ntags: ['npm', 'patch-package']\n---\n\n# 使用patch-package修改第三方模块\n\n在我们日常开发中，经常会遇到一些情况就是引用的`npm包`并不能完全满足我们的需求，或者在某些情况下触发了bug使得组建的展示和行为不正常。这个时候，我们就需要去修改npm包的代码了。\n\n但是，我们知道，我们不能直接进入`node_modules`中去修改包的代码。因为如果我们在本地的`node_modules`中修改了代码，可能在我们本地可以正常运行，但是如果团队的其他人员进行开发，甚至于使用`ci/cd`去部署项目时，由于它会重新下载新的包，这样你的改动就不能在其他机器上生效。\n\n那么我们就来看看如何正确地修改`npm包`里面的内容，同时能够同步给其他开发人员，使得大家的`npm包`都是统一修改过的版本。\n\n## 安装 patch-package\n```shell\n# npm\nnpm install patch-package --save-dev\n```\n\n## 修改并调试\n\n一般我们可以直接在npm的官网找到对于的`github`地址，从而下载到源码。`需要注意的是，我们下载的源码必须要与我们项目中引用的版本相同。`我们就以`easy-log-report`这个包为例子，我们可以找到它的对应仓库在 [https://github.com/zjw93615/EasyLog](https://github.com/zjw93615/EasyLog) 。我们就把项目的文件下载到本地并且打开。 之后在根目录上按照依赖。\n\n```shell\nnpm install\n```\n\n接着当我们修改完文件之后，我们怎么知道我们的修改是否生效呢？是否符合我们原来的预期呢？首先我们把修改好的项目`build`一下，不同的项目可能有不同的`build`方式，详细的可以看看项目的`package.json`或者`README.md`看是否有相关的说明。\n\n```shell\nnpm run build\n```\n\n编译完成之后，我们可以通过`link命令`，把我们修改好的包本地链接到引入了这个包的项目中。\n\n```shell\ncd ~/projects/easy-log-report     # 需要修改的包的根目录\nnpm link                          # 创建全局的npm link\n\ncd ~/projects/foo                 # 假设这个foo项目引用了easy-log-report这个包，去到foo的根目录\nnpm link easy-log-report          # 把easy-log-report这个包本地链接到foo这个项目\n```\n\n这样我们启动foo这个项目，我们就可以看到我们对于`easy-log-report`这个包的修改已经生效了。\n\n## 创建补丁\n\n在上面一步，我们已经把包修改完成并且完成调试了，这时候我们就可以把build好的文件拷贝到`node_modules`中对于的文件夹中。在这个例子中我们需要把~/projects/easy-log-report/build文件夹中的文件拷贝到~/projects/foo/node_modules/easy-log-report/build这个文件夹中。然后回到根目录执行patch-package。\n\n```shell\n# npm > 5.2\nnpx patch-package easy-log-report\n```\n执行完成后，会在项目根目录的 `patches`目录中创建补丁文件 `easy-log-report+1.0.3.patch（1.0.3 是依赖包版本）`，`这个补丁需要提交到代码仓库中`。\n\n如果我们打开`.patch`文件，我们可以发现其实就是一些`git diff`记录描述，那么`patch-package`补丁原理呼之欲出——`patch-package`会将当前`node_modules`下的源码与原始源码进行`git diff`，并在项目根目录下生成一个`patch`补丁文件。\n\n### options\n--use-yarn\npatch-package 默认是根据项目中的 lockfile 来决定使用 npm 还是 yarn，如果两种都有，则使用 npm，可以通过这个参数启用 yarn\n\n--exclude <regexp>\n创建补丁文件时，忽略与正则表达式匹配的路径，路径相对于要修改的依赖包的根目录，默认: package\\\\.json$\n\n--include <regexp>\n与 --exclude <regexp> 相反，创建补丁文件时仅考虑与正则表达式匹配的路径，默认: .*\n\n--case-sensitive-path-filtering\n使 --include 或 --exclude 中使用的正则表达式区分大小写\n\n--patch-dir\n指定放置补丁文件的目录\n\n## 打补丁\n\n当其他同事拉到代码如何应用补丁呢？基于上述操作我们在`npm install`后执行`patch-package`命令即可。\n```shell\nnpx patch-package\n```\n\n### options\n--reverse\n撤回所有补丁\nNote: 如果打补丁后，补丁文件被修改过，此操作将失败，此时可以重新安装 node_modules\n\n--patch-dir\n指定补丁文件所在目录\n\n## 完善npm脚本\n这个流程可借助`npm script`实现，在`package.json`的`script`中添加如下字段及内容：\n```js\n{\n    \"postinstall\": \"patch-package\"\n}\n```\n\n这样我们后续执行 npm install 或 yarn install 命令时，会自动为依赖包打补丁了\n\n","slug":"npm/使用patch-package修改第三方模块","published":1,"updated":"2023-04-14T07:39:44.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgg8q7u70000lac36ugyhxim","content":"<h1 id=\"使用patch-package修改第三方模块\"><a href=\"#使用patch-package修改第三方模块\" class=\"headerlink\" title=\"使用patch-package修改第三方模块\"></a>使用patch-package修改第三方模块</h1><p>在我们日常开发中，经常会遇到一些情况就是引用的<code>npm包</code>并不能完全满足我们的需求，或者在某些情况下触发了bug使得组建的展示和行为不正常。这个时候，我们就需要去修改npm包的代码了。</p>\n<p>但是，我们知道，我们不能直接进入<code>node_modules</code>中去修改包的代码。因为如果我们在本地的<code>node_modules</code>中修改了代码，可能在我们本地可以正常运行，但是如果团队的其他人员进行开发，甚至于使用<code>ci/cd</code>去部署项目时，由于它会重新下载新的包，这样你的改动就不能在其他机器上生效。</p>\n<p>那么我们就来看看如何正确地修改<code>npm包</code>里面的内容，同时能够同步给其他开发人员，使得大家的<code>npm包</code>都是统一修改过的版本。</p>\n<h2 id=\"安装-patch-package\"><a href=\"#安装-patch-package\" class=\"headerlink\" title=\"安装 patch-package\"></a>安装 patch-package</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">npm</span><br>npm install patch-package --save-dev<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"修改并调试\"><a href=\"#修改并调试\" class=\"headerlink\" title=\"修改并调试\"></a>修改并调试</h2><p>一般我们可以直接在npm的官网找到对于的<code>github</code>地址，从而下载到源码。<code>需要注意的是，我们下载的源码必须要与我们项目中引用的版本相同。</code>我们就以<code>easy-log-report</code>这个包为例子，我们可以找到它的对应仓库在 <a href=\"https://github.com/zjw93615/EasyLog\">https://github.com/zjw93615/EasyLog</a> 。我们就把项目的文件下载到本地并且打开。 之后在根目录上按照依赖。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">npm install<br></code></pre></td></tr></table></figure>\n\n<p>接着当我们修改完文件之后，我们怎么知道我们的修改是否生效呢？是否符合我们原来的预期呢？首先我们把修改好的项目<code>build</code>一下，不同的项目可能有不同的<code>build</code>方式，详细的可以看看项目的<code>package.json</code>或者<code>README.md</code>看是否有相关的说明。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">npm run build<br></code></pre></td></tr></table></figure>\n\n<p>编译完成之后，我们可以通过<code>link命令</code>，把我们修改好的包本地链接到引入了这个包的项目中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd ~/projects/easy-log-report     # 需要修改的包的根目录<br>npm link                          # 创建全局的npm link<br><br>cd ~/projects/foo                 # 假设这个foo项目引用了easy-log-report这个包，去到foo的根目录<br>npm link easy-log-report          # 把easy-log-report这个包本地链接到foo这个项目<br></code></pre></td></tr></table></figure>\n\n<p>这样我们启动foo这个项目，我们就可以看到我们对于<code>easy-log-report</code>这个包的修改已经生效了。</p>\n<h2 id=\"创建补丁\"><a href=\"#创建补丁\" class=\"headerlink\" title=\"创建补丁\"></a>创建补丁</h2><p>在上面一步，我们已经把包修改完成并且完成调试了，这时候我们就可以把build好的文件拷贝到<code>node_modules</code>中对于的文件夹中。在这个例子中我们需要把<del>&#x2F;projects&#x2F;easy-log-report&#x2F;build文件夹中的文件拷贝到</del>&#x2F;projects&#x2F;foo&#x2F;node_modules&#x2F;easy-log-report&#x2F;build这个文件夹中。然后回到根目录执行patch-package。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">npm &gt; 5.2</span><br>npx patch-package easy-log-report<br></code></pre></td></tr></table></figure>\n<p>执行完成后，会在项目根目录的 <code>patches</code>目录中创建补丁文件 <code>easy-log-report+1.0.3.patch（1.0.3 是依赖包版本）</code>，<code>这个补丁需要提交到代码仓库中</code>。</p>\n<p>如果我们打开<code>.patch</code>文件，我们可以发现其实就是一些<code>git diff</code>记录描述，那么<code>patch-package</code>补丁原理呼之欲出——<code>patch-package</code>会将当前<code>node_modules</code>下的源码与原始源码进行<code>git diff</code>，并在项目根目录下生成一个<code>patch</code>补丁文件。</p>\n<h3 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h3><p>–use-yarn<br>patch-package 默认是根据项目中的 lockfile 来决定使用 npm 还是 yarn，如果两种都有，则使用 npm，可以通过这个参数启用 yarn</p>\n<p>–exclude <regexp><br>创建补丁文件时，忽略与正则表达式匹配的路径，路径相对于要修改的依赖包的根目录，默认: package\\.json$</p>\n<p>–include <regexp><br>与 –exclude <regexp> 相反，创建补丁文件时仅考虑与正则表达式匹配的路径，默认: .*</p>\n<p>–case-sensitive-path-filtering<br>使 –include 或 –exclude 中使用的正则表达式区分大小写</p>\n<p>–patch-dir<br>指定放置补丁文件的目录</p>\n<h2 id=\"打补丁\"><a href=\"#打补丁\" class=\"headerlink\" title=\"打补丁\"></a>打补丁</h2><p>当其他同事拉到代码如何应用补丁呢？基于上述操作我们在<code>npm install</code>后执行<code>patch-package</code>命令即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">npx patch-package<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"options-1\"><a href=\"#options-1\" class=\"headerlink\" title=\"options\"></a>options</h3><p>–reverse<br>撤回所有补丁<br>Note: 如果打补丁后，补丁文件被修改过，此操作将失败，此时可以重新安装 node_modules</p>\n<p>–patch-dir<br>指定补丁文件所在目录</p>\n<h2 id=\"完善npm脚本\"><a href=\"#完善npm脚本\" class=\"headerlink\" title=\"完善npm脚本\"></a>完善npm脚本</h2><p>这个流程可借助<code>npm script</code>实现，在<code>package.json</code>的<code>script</code>中添加如下字段及内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;<br>    <span class=\"hljs-string\">&quot;postinstall&quot;</span>: <span class=\"hljs-string\">&quot;patch-package&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样我们后续执行 npm install 或 yarn install 命令时，会自动为依赖包打补丁了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用patch-package修改第三方模块\"><a href=\"#使用patch-package修改第三方模块\" class=\"headerlink\" title=\"使用patch-package修改第三方模块\"></a>使用patch-package修改第三方模块</h1><p>在我们日常开发中，经常会遇到一些情况就是引用的<code>npm包</code>并不能完全满足我们的需求，或者在某些情况下触发了bug使得组建的展示和行为不正常。这个时候，我们就需要去修改npm包的代码了。</p>\n<p>但是，我们知道，我们不能直接进入<code>node_modules</code>中去修改包的代码。因为如果我们在本地的<code>node_modules</code>中修改了代码，可能在我们本地可以正常运行，但是如果团队的其他人员进行开发，甚至于使用<code>ci/cd</code>去部署项目时，由于它会重新下载新的包，这样你的改动就不能在其他机器上生效。</p>\n<p>那么我们就来看看如何正确地修改<code>npm包</code>里面的内容，同时能够同步给其他开发人员，使得大家的<code>npm包</code>都是统一修改过的版本。</p>\n<h2 id=\"安装-patch-package\"><a href=\"#安装-patch-package\" class=\"headerlink\" title=\"安装 patch-package\"></a>安装 patch-package</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">npm</span><br>npm install patch-package --save-dev<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"修改并调试\"><a href=\"#修改并调试\" class=\"headerlink\" title=\"修改并调试\"></a>修改并调试</h2><p>一般我们可以直接在npm的官网找到对于的<code>github</code>地址，从而下载到源码。<code>需要注意的是，我们下载的源码必须要与我们项目中引用的版本相同。</code>我们就以<code>easy-log-report</code>这个包为例子，我们可以找到它的对应仓库在 <a href=\"https://github.com/zjw93615/EasyLog\">https://github.com/zjw93615/EasyLog</a> 。我们就把项目的文件下载到本地并且打开。 之后在根目录上按照依赖。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">npm install<br></code></pre></td></tr></table></figure>\n\n<p>接着当我们修改完文件之后，我们怎么知道我们的修改是否生效呢？是否符合我们原来的预期呢？首先我们把修改好的项目<code>build</code>一下，不同的项目可能有不同的<code>build</code>方式，详细的可以看看项目的<code>package.json</code>或者<code>README.md</code>看是否有相关的说明。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">npm run build<br></code></pre></td></tr></table></figure>\n\n<p>编译完成之后，我们可以通过<code>link命令</code>，把我们修改好的包本地链接到引入了这个包的项目中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd ~/projects/easy-log-report     # 需要修改的包的根目录<br>npm link                          # 创建全局的npm link<br><br>cd ~/projects/foo                 # 假设这个foo项目引用了easy-log-report这个包，去到foo的根目录<br>npm link easy-log-report          # 把easy-log-report这个包本地链接到foo这个项目<br></code></pre></td></tr></table></figure>\n\n<p>这样我们启动foo这个项目，我们就可以看到我们对于<code>easy-log-report</code>这个包的修改已经生效了。</p>\n<h2 id=\"创建补丁\"><a href=\"#创建补丁\" class=\"headerlink\" title=\"创建补丁\"></a>创建补丁</h2><p>在上面一步，我们已经把包修改完成并且完成调试了，这时候我们就可以把build好的文件拷贝到<code>node_modules</code>中对于的文件夹中。在这个例子中我们需要把<del>&#x2F;projects&#x2F;easy-log-report&#x2F;build文件夹中的文件拷贝到</del>&#x2F;projects&#x2F;foo&#x2F;node_modules&#x2F;easy-log-report&#x2F;build这个文件夹中。然后回到根目录执行patch-package。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">npm &gt; 5.2</span><br>npx patch-package easy-log-report<br></code></pre></td></tr></table></figure>\n<p>执行完成后，会在项目根目录的 <code>patches</code>目录中创建补丁文件 <code>easy-log-report+1.0.3.patch（1.0.3 是依赖包版本）</code>，<code>这个补丁需要提交到代码仓库中</code>。</p>\n<p>如果我们打开<code>.patch</code>文件，我们可以发现其实就是一些<code>git diff</code>记录描述，那么<code>patch-package</code>补丁原理呼之欲出——<code>patch-package</code>会将当前<code>node_modules</code>下的源码与原始源码进行<code>git diff</code>，并在项目根目录下生成一个<code>patch</code>补丁文件。</p>\n<h3 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h3><p>–use-yarn<br>patch-package 默认是根据项目中的 lockfile 来决定使用 npm 还是 yarn，如果两种都有，则使用 npm，可以通过这个参数启用 yarn</p>\n<p>–exclude <regexp><br>创建补丁文件时，忽略与正则表达式匹配的路径，路径相对于要修改的依赖包的根目录，默认: package\\.json$</p>\n<p>–include <regexp><br>与 –exclude <regexp> 相反，创建补丁文件时仅考虑与正则表达式匹配的路径，默认: .*</p>\n<p>–case-sensitive-path-filtering<br>使 –include 或 –exclude 中使用的正则表达式区分大小写</p>\n<p>–patch-dir<br>指定放置补丁文件的目录</p>\n<h2 id=\"打补丁\"><a href=\"#打补丁\" class=\"headerlink\" title=\"打补丁\"></a>打补丁</h2><p>当其他同事拉到代码如何应用补丁呢？基于上述操作我们在<code>npm install</code>后执行<code>patch-package</code>命令即可。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">npx patch-package<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"options-1\"><a href=\"#options-1\" class=\"headerlink\" title=\"options\"></a>options</h3><p>–reverse<br>撤回所有补丁<br>Note: 如果打补丁后，补丁文件被修改过，此操作将失败，此时可以重新安装 node_modules</p>\n<p>–patch-dir<br>指定补丁文件所在目录</p>\n<h2 id=\"完善npm脚本\"><a href=\"#完善npm脚本\" class=\"headerlink\" title=\"完善npm脚本\"></a>完善npm脚本</h2><p>这个流程可借助<code>npm script</code>实现，在<code>package.json</code>的<code>script</code>中添加如下字段及内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;<br>    <span class=\"hljs-string\">&quot;postinstall&quot;</span>: <span class=\"hljs-string\">&quot;patch-package&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这样我们后续执行 npm install 或 yarn install 命令时，会自动为依赖包打补丁了</p>\n"}],"PostAsset":[{"_id":"source/_posts/Javascript/原型与原型链/img.png","slug":"img.png","post":"clgey0sex000afpc37zgf6i0g","modified":0,"renderable":0},{"_id":"source/_posts/Javascript/原型与原型链/img_1.png","slug":"img_1.png","post":"clgey0sex000afpc37zgf6i0g","modified":0,"renderable":0},{"_id":"source/_posts/Javascript/原型与原型链/img_2.png","slug":"img_2.png","post":"clgey0sex000afpc37zgf6i0g","modified":0,"renderable":0},{"_id":"source/_posts/Javascript/原型与原型链/img_3.png","slug":"img_3.png","post":"clgey0sex000afpc37zgf6i0g","modified":0,"renderable":0}],"PostCategory":[{"post_id":"clgey0sex000afpc37zgf6i0g","category_id":"clgey1vwu000nfpc38ut1hzjk","_id":"clgey1vwv000ofpc35c9x64r7"},{"post_id":"clgey0sev0007fpc3ah1k8wl8","category_id":"clgey1vwu000nfpc38ut1hzjk","_id":"clgey1vwz000qfpc3akfz6ya4"},{"post_id":"clgey11v4000dfpc32wr41d62","category_id":"clgey1vwy000pfpc32dlsevur","_id":"clgey1vx1000sfpc308n9689a"},{"post_id":"clgey1jv0000gfpc3aor31675","category_id":"clgey1vx0000rfpc38fes53mu","_id":"clgey1vx3000ufpc3amda08lj"},{"post_id":"clgey1juy000ffpc3as1lfy3r","category_id":"clgey1vx0000rfpc38fes53mu","_id":"clgey1vx3000vfpc39c7jhtr0"}],"PostTag":[{"post_id":"clgey0sev0007fpc3ah1k8wl8","tag_id":"clgewtv3h0001o5c3dj1a263v","_id":"clgey0sew0008fpc3aqcn20rz"},{"post_id":"clgey0sev0007fpc3ah1k8wl8","tag_id":"clgewtv3j0002o5c3atfy9424","_id":"clgey0sew0009fpc3cjdc6icg"},{"post_id":"clgey0sex000afpc37zgf6i0g","tag_id":"clgewtv3h0001o5c3dj1a263v","_id":"clgey0sey000bfpc3bujo49w8"},{"post_id":"clgey0sex000afpc37zgf6i0g","tag_id":"clgewtv3j0002o5c3atfy9424","_id":"clgey0sey000cfpc31rq6gvl4"},{"post_id":"clgey11v4000dfpc32wr41d62","tag_id":"clgexqw4900012uc3hk9w24zv","_id":"clgey11v6000efpc3dv7q8wfw"},{"post_id":"clgey1juy000ffpc3as1lfy3r","tag_id":"clgewtv3h0001o5c3dj1a263v","_id":"clgey1jv1000hfpc34ydaei3t"},{"post_id":"clgey1juy000ffpc3as1lfy3r","tag_id":"clgextzjt000b2uc3ekfoa90v","_id":"clgey1jv1000ifpc31kgp6ac2"},{"post_id":"clgey1juy000ffpc3as1lfy3r","tag_id":"clgexu6zl000e2uc33yxf9qap","_id":"clgey1jv1000jfpc3a3ezhso1"},{"post_id":"clgey1jv0000gfpc3aor31675","tag_id":"clgext1zq00042uc3f2j2de32","_id":"clgey1jv2000kfpc30ap49fqq"},{"post_id":"clgey1jv0000gfpc3aor31675","tag_id":"clgext1zy00052uc353ka8x68","_id":"clgey1jv2000lfpc3dwxf9dtc"},{"post_id":"clgey1jv0000gfpc3aor31675","tag_id":"clgext1zz00062uc3fo40csf6","_id":"clgey1jv2000mfpc38yr408x1"},{"post_id":"clgg8q7u70000lac36ugyhxim","tag_id":"clgextzjt000b2uc3ekfoa90v","_id":"clgg8q7ud0002lac3g8meeslv"},{"post_id":"clgg8q7u70000lac36ugyhxim","tag_id":"clgg8q7ua0001lac32ibaeidx","_id":"clgg8q7ud0003lac362ndhxdi"}],"Tag":[{"name":"javascript","_id":"clgewtv3h0001o5c3dj1a263v"},{"name":"es6","_id":"clgewtv3j0002o5c3atfy9424"},{"name":"css","_id":"clgexqw4900012uc3hk9w24zv"},{"name":"ChatGPT","_id":"clgext1zq00042uc3f2j2de32"},{"name":"nodejs","_id":"clgext1zy00052uc353ka8x68"},{"name":"SSE","_id":"clgext1zz00062uc3fo40csf6"},{"name":"npm","_id":"clgextzjt000b2uc3ekfoa90v"},{"name":"日志","_id":"clgexu6zl000e2uc33yxf9qap"},{"name":"javascript['', 'npm', '日志']","_id":"clgexy8600002fpc35pea1l28"},{"name":"patch-package","_id":"clgg8q7ua0001lac32ibaeidx"}]}}