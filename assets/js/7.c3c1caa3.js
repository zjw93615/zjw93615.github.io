(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{280:function(e,t,a){"use strict";a.r(t);var s=a(14),v=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"es6-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-新特性"}},[e._v("#")]),e._v(" ES6 新特性")]),e._v(" "),t("p",[e._v("本文只是简单概括ES6的一些新特性，想要详细了解，可以参阅"),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla",target:"_blank",rel:"noopener noreferrer"}},[e._v("MDN"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://es6.ruanyifeng.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("ES6入门"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。")]),e._v(" "),t("h2",{attrs:{id:"let-与-const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let-与-const"}},[e._v("#")]),e._v(" let 与 const")]),e._v(" "),t("p",[t("code",[e._v("ES2015(ES6)")]),e._v("新增加了两个重要的"),t("code",[e._v("JavaScript")]),e._v("关键字: "),t("code",[e._v("let")]),e._v("和"),t("code",[e._v("const")]),e._v("。 "),t("code",[e._v("ES6")]),e._v("明确规定，代码块内如果存在"),t("code",[e._v("let")]),e._v("或者"),t("code",[e._v("const")]),e._v("，代码块会对这些命令声明的变量从块的开始就形成一个"),t("strong",[e._v("封闭作用域")]),e._v("。代码块内，在"),t("strong",[e._v("声明变量之前")]),e._v("使用它会"),t("strong",[e._v("报错")]),e._v("，称为"),t("strong",[e._v("暂时性死区")]),e._v("。 "),t("code",[e._v("ES6")]),e._v("的块级作用域必须有大括号，如果没有大括号，"),t("code",[e._v("JavaScript")]),e._v("引擎就认为不存在块级作用域。")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("let")]),e._v("和"),t("code",[e._v("const")]),e._v("只能声明一次，"),t("code",[e._v("var")]),e._v("可以声明多次。")]),e._v(" "),t("li",[t("code",[e._v("var")]),e._v("会变量提升，"),t("code",[e._v("let")]),e._v("与"),t("code",[e._v("const")]),e._v("也存在变量提升但有所不同。")]),e._v(" "),t("li",[t("code",[e._v("const")]),e._v("声明一个只读的常量，一旦声明，常量的值就不能改变。")]),e._v(" "),t("li",[t("code",[e._v("const")]),e._v("和"),t("code",[e._v("let")]),e._v("在全局作用域中声明的变量不会挂载到"),t("code",[e._v("window")]),e._v("上。")]),e._v(" "),t("li",[t("code",[e._v("let")]),e._v("和"),t("code",[e._v("const")]),e._v("声明的变量只在其声明所在的代码块内有效，形成块级作用域。")]),e._v(" "),t("li",[t("code",[e._v("const")]),e._v("其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。对于基本数据类型"),t("code",[e._v("number、string 、boolean")]),e._v("等，值就保存在变量指向的那个内存地址，因此"),t("code",[e._v("const")]),e._v(" 声明的简单类型变量等同于常量。而引用类型"),t("code",[e._v("object，array，function")]),e._v("等，变量指向的内存地址其实是保存了一个指向实际数据的指针，所以"),t("code",[e._v("const")]),e._v("只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了。")])]),e._v(" "),t("h2",{attrs:{id:"解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解构赋值"}},[e._v("#")]),e._v(" 解构赋值")]),e._v(" "),t("p",[t("code",[e._v("ES6")]),e._v("允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let [a, b, c] = [1, 2, 3]; // 基本\nlet [a, [[b], c]] = [1, [[2], 3]]; //嵌套\nlet [a, , b] = [1, 2, 3]; // 可忽略\nlet [a = 1, b] = []; // a = 1, b = undefined // 不完全解构\nlet [a, ...b] = [1, 2, 3]; // 剩余运算符\nlet [a, b, c, d, e] = 'hello'; // 字符串等\nlet { a, b } = { a: 'aaa', b: 'bbb' }; // 对象模型的解构 前后两个kay需对应\n")])])]),t("h2",{attrs:{id:"symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[e._v("#")]),e._v(" Symbol")]),e._v(" "),t("p",[t("code",[e._v("ES6")]),e._v("引入了一种新的原始数据类型"),t("code",[e._v("Symbol")]),e._v("，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。 "),t("code",[e._v("ES6")]),e._v("数据类型除了"),t("code",[e._v("Number")]),e._v("、"),t("code",[e._v("String")]),e._v("、"),t("code",[e._v("Boolean")]),e._v("、 "),t("code",[e._v("Object")]),e._v("、"),t("code",[e._v("null")]),e._v("和"),t("code",[e._v("undefined")]),e._v("，还新增了 "),t("code",[e._v("Symbol")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let s1 = Symbol("s");\nlet s2 = Symbol("s");\nconsole.log(s1 === s2); //false\n')])])]),t("h2",{attrs:{id:"spread-rest-操作符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spread-rest-操作符"}},[e._v("#")]),e._v(" Spread / Rest 操作符")]),e._v(" "),t("p",[t("code",[e._v("Spread")]),e._v(" 用于将数组作为参数直接传入函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var s = ['1', '2', '3'];\nfunction f(s1,s2,s3){\n    console.log(`Hello ${s1},${s2},${s3}`); //ES6新增字符串中加入变量和表达式\n}\nf(...s); //Hello 1,2,3\n")])])]),t("p",[t("code",[e._v("Rest")]),e._v(" 用于函数传参传递数组。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function f(...args){\n    console.log(args);\n}\nf(1,2,3,4,5); //[1, 2, 3, 4, 5]\n")])])]),t("h2",{attrs:{id:"箭头函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[e._v("#")]),e._v(" 箭头函数")]),e._v(" "),t("p",[t("code",[e._v("ES6")]),e._v("中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 "),t("code",[e._v("=>")]),e._v("，紧接着是函数体，特别需要注意的是箭头函数是继承当前上下文的"),t("code",[e._v("this")]),e._v("关键字。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var add = (a, b) => a + b;\nvar show = a => console.log(a);\nvar test = (a,b,c) => {console.log(a,b,c);return a+b+c;}\nadd(1,1); //2\nshow(1); //1\ntest(1,1,1); //1 1 1\n")])])]),t("h2",{attrs:{id:"参数默认值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参数默认值"}},[e._v("#")]),e._v(" 参数默认值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function f(a = 1){\n    console.log(a);\n}\nf(); //1\nf(11); //11\n")])])]),t("h2",{attrs:{id:"迭代器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[e._v("#")]),e._v(" 迭代器")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Symbol.iterator")]),e._v(" 一个统一的接口，它的作用是使各种数据结构可被便捷的访问。")]),e._v(" "),t("li",[e._v("for of 是 ES6 新引入的循环，用于替代 "),t("code",[e._v("for..in")]),e._v(" 和 "),t("code",[e._v("forEach()")]),e._v("。")])]),e._v(" "),t("h2",{attrs:{id:"类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[e._v("#")]),e._v(" 类")]),e._v(" "),t("p",[t("code",[e._v("ES6")]),e._v("提供了更接近传统语言的写法，引入了"),t("code",[e._v("class")]),e._v("这个概念，作为对象的模板。通过"),t("code",[e._v("class")]),e._v("关键字，可以定义类，与多数传统语言类似。不过，"),t("code",[e._v("ES6")]),e._v("的"),t("code",[e._v("class")]),e._v("不是新的对象继承模型，它只是原型链的语法糖表现形式。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Me {\n  constructor() {\n    console.log(\"constructor\");\n  }\n  study() {\n    console.log('study');\n  }\n}\n\nconsole.log(typeof Me); //function\nlet me = new Me(); //constructor\nme.study(); //study\n")])])]),t("h2",{attrs:{id:"promise-对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象"}},[e._v("#")]),e._v(" Promise 对象")]),e._v(" "),t("p",[t("code",[e._v("Promise")]),e._v("是异步编程的一种解决方案。")]),e._v(" "),t("p",[e._v("从语法上说，"),t("code",[e._v("Promise")]),e._v(" 是一个对象，从它可以获取异步操作的消息。\nPromise异步操作有三种状态："),t("code",[e._v("pending")]),e._v("、"),t("code",[e._v("fulfilled")]),e._v("和"),t("code",[e._v("rejected")]),e._v("。除了异步操作的结果，任何其他操作都无法改变这个状态。\n"),t("code",[e._v("then")]),e._v("方法接收两个函数作为参数，第一个参数是"),t("code",[e._v("Promise")]),e._v("执行成功时的回调，第二个参数是 "),t("code",[e._v("Promise")]),e._v("执行失败时的回调，两个函数只会有一个被调用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const p1 = new Promise(function(resolve,reject){\n    resolve('resolve');\n}); \nconst p2 = new Promise(function(resolve,reject){\n    reject('reject');\n});\np1.then(function(v){  \n    console.log(v); //resolve\n});\np2.then(function(v){ \n    console.log(v);\n},\nfunction(v){\n    console.log(v); //reject\n});\n\n")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);